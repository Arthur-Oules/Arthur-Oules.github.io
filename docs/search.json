[
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "You can find the materials for my lectures and workshop at the Biology department of the Ecole Normale Supérieure de Lyon.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPCA_Class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTD 2 de Phylogénie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTD Biodiversité\n\n\n\n\n\n\n\n\n\n\n\nArthur Oulès, adapté de Thibaut Jombart (2013)\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1_correction.html",
    "href": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1_correction.html",
    "title": "TD 2 de Phylogénie - Correction",
    "section": "",
    "text": "Un Xenomorphe de la saga Alien nous faisant de jolis sourires (Xenopedia)\nConnaissances travaillées :\nCompétences travaillées :"
  },
  {
    "objectID": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1_correction.html#la-pharyngognathie-chez-les-téléostéens",
    "href": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1_correction.html#la-pharyngognathie-chez-les-téléostéens",
    "title": "TD 2 de Phylogénie - Correction",
    "section": "La pharyngognathie chez les Téléostéens",
    "text": "La pharyngognathie chez les Téléostéens\nLes poissons Téléostéens possèdent, en plus de leurs mâchoires orales, une deuxième paire de mâchoires appelées mâchoires pharyngiennes (Figure 1).\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\nFigure 1: Diagramme des os du crâne d’un poisson Téléostéen (ici le Cichlidé Herichtys minckleyi).\nLes os de la mâchoire orale sont colorés en violet et ceux de la mâchoire pharyngienne en bleu. La barre d’échelle représente 5 mm. (Adapté d’A. Oulès)\n\n\n\nQ1 : Quel peut-être l’intérêt fonctionnel de cette seconde paire de mâchoires ?\n\n\n\n\n\n\nRéponse 1\n\n\n\n\n\nChez les poissons chirurgiens (Acanthuridae), les mâchoires pharyngiennes sont réduites à des plaques dentigères dont l’action dans la mastication est très réduite.\nA l’inverse, chez les poissons rouges (Cyprinidés), les mâchoires orales sont édentées et seules les mâchoires pharyngiennes portent des dents. Ainsi la mâchoire orale permet la capture de proies par succion et les mâchoires pharyngiennes permettent la mastication.\nLa présence de mâchoires pharyngiennes permet un découplage fonctionnel des mâchoires orales et pharyngiennes et le relâchement d’une partie des pressions de sélection exercées sur les mâchoires orales.\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n(a) Mâchoires pharyngiennes d’une Murène (Mehta & Wainright 2007) DOI : 10.1038/nature06062\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n(b) Diversité des mâchoires pharyngiennes des Cichlidés (Burress 2015) DOI : 10.1111/1365-2656.12457\n\n\n\n\n\n \n\n\n\n\nFigure 2: Diversité des mâchoires pharyngiennes chez les Téléostéens\n\n\n\nQ2 : Pouvez-vous émettre une hypothèse sur l’origine développementale de ces mâchoires ?\n\n\n\n\n\n\nRéponse 2\n\n\n\n\n\nLes mâchoires pharyngiennes sont positionnées postérieurement aux opercules, à l’emplacement du cinquième arc branchial chez les poissons sans mâchoires pharyngiennes. Une étude de leur ontogénie montre qu’elles sont issues d’une modification du cinquième arc branchial des Téléostéens.\n\n\n\nChez certains groupes, ce caractère est associé à de nombreuses modifications comme la fusion des demi-mâchoires pharyngiennes inférieures et une modification de la musculature associée (Figure 2). Ces modifications permettent notamment une force de mastication supérieure et l’apparition de régimes alimentaires à base d’aliments coriaces comme les molluscivores ou les corallivores, ce mode d’alimentation à partir de mâchoires pharyngiennes dérivées est appelé pharyngognathie.\n\n\n\n\n\n\nDocument 1: Impact de la pharyngognathie sur la transition de régime alimentaire chez les poissons marins. (McGee et al 2015 DOI : 10.1126/science.aab0800)\n(A) Quatre transitions vers la pharyngognathie sur une phylogénie de 851 Actinoptérygiens calibrée temporellement. (1) Les Labres (Labridae et Scaridae); (2) Les Embiotocidae; (3) Les Demoiselles (Pomacentridae); (4) Les Hemirhamphidae\n(B) Comparaison des taux de transitions de régime alimentaire vers la piscivorie (poissons non larvaires) ou vers des proies à mastication intense (détritus, plantes, proies à coquilles dures), pour des pour des poissons pharyngognathes ou non.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa construction des phylogénies calibrées (ou chronogrammes) est abordée plus en détails dans la section suivante du TD.\n\n\nQ3 : À partir du Document 1 A, décrivez l’évolution de la pharyngognathie chez les Actinoptérygiens.\n\n\n\n\n\n\nRéponse 3\n\n\n\n\n\nC’est un chronogramme, donc un arbre phylogénétique calibré temporellement. Ici, il est représenté circulairement bien qu’il ait été raciné avant sa calibration temporelle. Les feuilles, le long du périmètre du cercle, correspondent au présent et la racine, au centre, est le point le plus ancien temporellement. Cet arbre inclut 851 espèces, c’est ce qu’on appelle une méga phylogénie. Les branches de l’arbre correspondant à des espèces pharyngognathes sont colorées en rouge et à des non-pharyngognathes en bleu.\nOn observe 4 clades pharyngognathes différents, l’hypothèse la plus parcimonieuse est celle d’une convergence évolutive, les hypothèses alternatives étant moins parcimonieuses (celle qui nécessite le moins de changements évolutifs) car demandant trop de réversions. La pharyngognathie serait donc un caractère polyphylétique.\n\n\n\nExtrait 1 : The degree of piscivory was defined as the volumetric percentage of non-larval fish in the diet, and the degree of processing-intensive prey was defined as the volumetric percentage of plants, algae, and detritus combined with the percentage of hard-shelled prey like bivalves, shelled gastropods, and hard-bodied echinoderms (i. e. no holothurian “sea cucumbers”).\nWe used the brownie.lite function in the phytools R package to test whether each diet category was best modeled as a one-rate model across the tree, or a model where rates differed between pharyngognathous and non-pharyngognathous marine fishes. There was a strong preference for a two-rate model for both fish prey (∆AICc = -293) and processing-intensive prey (∆AICc = -59). For both traits, the difference between pharyngognaths and non-pharyngognaths for the Brownian rate parameter in the two-rate model was always significant (p &lt; 0.001).\n\n\n\n\n\n\nNote\n\n\n\nAIC = Akaike Information Criterion (Critère d’information d’Akaike) est une mesure de la qualité relative d’un modèle statistique sachant un ensemble de données. Lorsque l’on estime un modèle statistique, il est possible d’augmenter la vraisemblance du modèle en ajoutant un paramètre. Le critère d’information d’Akaike prend cela en compte en pénalisant les modèles en fonction du nombre de paramètres. On choisit alors le modèle avec le critère d’information d’Akaike le plus faible.\nLe ∆AICc inclut une correction liée à la taille du jeu de données.\n\n\nQ4 : Qu’est-ce qu’un mouvement Brownien ? Comment peut-il être utilisé pour modéliser l’évolution d’un trait continu ?\n\n\n\n\n\n\nRéponse 4\n\n\n\n\n\nLa description historique du mouvement Brownien est attribuée à Robert Brown en 1827 alors qu’il observait des grains de pollen dans une goutte d’eau au microscope. Leurs déplacements stochastiques l’ont intrigué mais la modélisation mathématique de ce phénomène n’a eu lieu qu’à la fin du siècle.\nStatistiquement, la position \\(\\bar{z}(t)\\) d’une particule suivant un mouvement Brownien est décrite par une marche aléatoire avec les caractéristiques suivantes :\n\n\\(E[\\bar{z}(t)] = \\bar{z}(0)\\), le mouvement moyen est nul autour de la position de départ. Le mouvement n’a pas de tendance particulière\nLes différents “pas” infinitésimaux de la marche sont indépendants\n\\(\\bar{z}(t) \\sim \\mathcal{N}(\\bar{z}(0), σ^2t)\\) Le mouvement de la particule à un instant \\(t\\) suit une loi normale de moyenne \\(\\bar{z}(0)\\) et de variance \\(\\sigma^2t\\)\n\nDans le cas de notre grain de pollen, si l’on considère que ses mouvements sont influencés par la somme des chocs imposés par les molécules d’eau environnantes, peu importe les lois décrivant les mouvements de ces molécules, leur somme tend vers une loi normale par le théorème central limite.\nAinsi, c’est le paramètre \\(\\sigma^2\\) qui est déterminant dans la description de cette marche.\nRevenons à la description de l’évolution de traits continus. Prenons la masse corporelle, on peut légitimement supposer que ce trait est contrôlé par une multitude de gènes subissant des mutations aléatoires. Ainsi, la somme de petits écarts de la valeur de ce trait dues à des mutations de ces gènes peut être vu comme une marche aléatoire, de la même manière que les molécules d’eau décalant le grain de pollen par collision.\nOn peut donc appliquer des hypothèses de travail similaire et utiliser le même modèle mathématique. Dans ce cas, \\(\\bar{z}(0)\\) est l’état ancestral et \\(\\sigma^2\\) le taux d’évolution.\nLa modélisation et les hypothèses de travail sont grandement simplifiées dans ces explications, pour approfondir ce concept, je vous redirige vers le chapitre 3 cet excellent livre de Luke J. Harmon : https://lukejharmon.github.io/pcm/chapters/.\n\n\n\nQ5 : Rappeler le principe du maximum de vraisemblance. La fonction brownie.lite inclut ce principe, à votre avis, de quelle façon ?\n\n\n\n\n\n\nRéponse 5\n\n\n\n\n\nCommençons par un exemple simple et concret, une pièces de monnaie que l’on lance douze fois avec le tirage suivant :\n\\[\nP - F - F - P - F - P - P - F - F - F - P - F\n\\]\nOn veut à présent vérifier si la pièce est truquée ou non, on va donc dans un premier temps faire l’hypothèse qu’elle ne l’est pas et donc que les chances d’obtenir pile ou face sont de 50% chacune, on a alors la probabilité d’obtenir ce tirage sachant que la pièce est équilibrée qui vaut :\n\\[\nP(\\text{Tirage}|\\text{Pièce équilibrée}) = (0,5)^7 \\times (0,5)^5 = 2,4 \\cdot 10^{-4}\n\\]\nMaintenant, avec l’hypothèse d’une pièce biaisée avec 70% d’obtenir face, on obtient :\n\\[\nP(\\text{Tirage}|\\text{Pièce truquée}) = (0,7)^7 \\times (0,3)^5 = 2,0 \\cdot 10^{-4}\n\\]\nOn a donc \\(P(\\text{Tirage}|\\text{Pièce équilibrée}) &gt; P(\\text{Tirage}|\\text{Pièce truquée})\\), on dit qu’il est plus vraisemblable que la pièce soit équilibrée.\nFormellement, la vraisemblance d’un modèle sachant un jeu de donnée est la probabilité conditionnelle d’obtenir un jeu de données sachant un modèle.\nAinsi, on peut définir une fonction qui à un ensemble de modèles va attribuer une valeur de vraisemblance : la fonction de vraisemblance. C’est cette fonction que l’on cherche à maximiser afin de trouver le modèle qui, sachant nos donnée, est le “meilleur” d’après nos critères.\nDans notre exemple simplifié, on peut écrire que pour toute chance \\(p\\) de tomber sur Face qui décrit un modèle on a : \\[\n\\mathcal{L}(\\text{modele}(p) | \\text{Tirage}) = P(\\text{Tirage} | \\text{modele}(p)) = (p)^7 \\cdot (1-p)^5\n\\] Où \\(\\mathcal{L}\\) est la fonction de vraisemblance du modèle sachant le tirage qu’on a eu. Il est donc simple de trouver une solution analytique dans ce cas !\nCependant, quand on travaille avec des phylogénie ou des modèles complexes de manière générale, on a bien plus de paramètres et pas toujours de solution analytique et il faut passer par des estimations de cette fonction qui sont gourmandes en puissance et temps de calcul.\nDans le cas de la fonction brownie.lite, l’évolution du trait le long d’un arbre est modélisée par un mouvement Brownien de paramètres \\(\\bar{z}(0)\\) et \\(\\sigma^2\\) comme vu en réponse à la question précédente et le maximum de vraisemblance permet de trouver le jeu de paramètres (le taux d’évolution du degré de piscivorie et le caractère ancestral) le plus vraisemblable sachant notre jeu de donnée (la topologie d’arbre et les caractères actuels).\n\n\n\nQ6 : Quel est le résultat obtenu à l’issue de ces tests ?\n\n\n\n\n\n\nRéponse 6\n\n\n\n\n\nLes chercheurs ont testé si le taux d’évolution des régimes alimentaires testés étaient différents en fonction du caractère pharyngognathe ou non-pharyngognathe. Dans un premier temps, ils étudient la transition vers la piscivorie.\nPour cela, ils ont construit deux modèles dont l’un est la simplification de l’autre (on parle de modèles emboîtés). Dans le modèle M0 le plus simple, le paramètre estimé (transition vers la piscivorie) a la même valeur dans tout l’arbre. Dans le modèle M1 plus complexe, le taux de transition vers la piscivorie peut avoir deux valeurs différentes dans les branches rouges et bleues. Ils calculent le maximum de vraisemblance pour M0 et M1 et comparent ces vraisemblances pour choisir le meilleur modèle, c’est-à-dire le modèle le plus simple possible qui explique au mieux les données (grâce à l’AIC).\nIls choisissent M1 et concluent que les taux de transitions sont significativement différents dans les deux cas (pharyngognathes vs. non-pharyngognathes) et pour les deux régimes alimentaires testés (piscivorie et mastication intense).\n\n\n\nExtrait 2 : Our Brownian rate analysis treated the percentage of either processing-intensive or fish prey as a continuous character. However, if we define each species as a prey specialist if it eats over a certain percentage of that prey in its diet, we can also analyze diet as a categorical variable using stochastic character mapping.\nWe also used stochastic character mapping in the phytools package to examine transitions between dietary strategies. Fish were scored as processing-intensive if they had a mean value of processing-intensive prey over 25% of their diet, and as piscivorous if the mean value of non-larval fish in their diet was higher than 25%. Each fish was then scored as non-pharyngognath non-piscivore, non-pharyngognath piscivore, pharyngognath non-piscivore, and pharyngognath piscivore.\nWe used the fitDiscrete function in the R package geiger to compare the transition rate matrix for two models of character evolution. Specifically, we tested a model with equal transition rates between non-pharyngognath non-piscivores and non-pharyngognath piscivores versus between pharyngognath non-piscivores and pharyngognath piscivores. We then compared this equal-rate model to one where the transition rates were allowed to differ. All other rates were allowed to differ. Transitions were always modeled as symmetric, i. e. equal rates into and out of a category.\nQ7 : Pourquoi recalculer les taux de transition en considérant, cette-fois, le trait comme discret ? Quelle(s) différence(s) avec le modèle précédent ?\n\n\n\n\n\n\nRéponse 7\n\n\n\n\n\nDes caractères comme le régime alimentaire ont des composantes discrètes et continues. Comme montré par ces chercheurs, on peut catégoriser les régimes alimentaires en variable discrète, ce qui permet de mieux détecter des évènements de convergence par exemple, ou au contraire comme une variable continue. En réalité, le régime alimentaire est rarement discret et, au moins par opportunisme, les organismes peuvent dévier en partie de leur régime alimentaire préféré. Ce degré de liberté dans le régime alimentaire peut être un paramètre pertinent à étudier.\nUne autre façon de voir les choses est que le modèle continu se rapproche d’une vision gradualiste de l’évolution et le modèle discret d’une évolution par équilibres ponctués. Ces deux visions sont complémentaires et décrivent des processus différents, ainsi coupler ces deux approches peut permettre de détecter ces processus.\nOutre ces considérations, multiplier les approches apporte de la robustesse aux résultats.\n\n\n\nExtrait 3 : AIC strongly favored the model where non-pharyngognaths had a different transition rate into and out of piscivory as compared to pharyngognaths (ΔAIC = -20.3). We used a similar character mapping scheme and analysis for pharyngognathy and processing-intensive prey, and found a preference for different rates of transition within pharyngognaths as compared to non-pharyngognaths (ΔAIC = -8.6). Rates of transition between piscivory and non-piscivory were an order of magnitude higher in non-pharyngognaths (7.96e-03 vs. 9.95e-04, Document 1 B). For processing-intensive prey, rates were an order of magnitude lower in non-pharyngognaths (4.03e-03 vs. 1.15e-02, Document 1 B).\nQ8 : Ces résultats corroborent-ils ceux obtenus en considérant la variable comme continue ? Quelles différences observe-t-on entre les poissons pharyngognathes et non-pharyngognathes ?\n\n\n\n\n\n\nRéponse 8\n\n\n\n\n\nOui, ces résultats sont en accord avec les résultats précédents. On observe que, pour un régime alimentaire donné, le taux de transition est différent entre pharyngognathes et non-pharyngognathes.\nCe taux est plus important pour les pharyngognathes pour une transition vers la mastication intense et plus important pour les non-pharyngognathes pour une transition vers la piscivorie. Ainsi, la pharyngognathie semble favoriser des transitions vers des régimes alimentaires demandant une mastication intense mais réduire les transitions vers la piscivorie."
  },
  {
    "objectID": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1_correction.html#diversification-des-régimes-alimentaires-et-radiation-évolutive-chez-les-cichlidés-des-grands-lacs-africains",
    "href": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1_correction.html#diversification-des-régimes-alimentaires-et-radiation-évolutive-chez-les-cichlidés-des-grands-lacs-africains",
    "title": "TD 2 de Phylogénie - Correction",
    "section": "Diversification des régimes alimentaires et radiation évolutive chez les Cichlidés des grands lacs Africains",
    "text": "Diversification des régimes alimentaires et radiation évolutive chez les Cichlidés des grands lacs Africains\n\n\n\n\n\n\nDocument 2: Phylogénie RAxML des Tropheini calibrée temporellement et faisant apparaître les reconstructions des traits ancestraux pour la spécialisation trophique. (Singh et al 2022) DOI : 10.1002/ece3.9077\nL’arbre a été reconstitué par maximum de vraisemblance. Les temps de divergences ont été inférés avec RelTime à partir d’un schéma de calibration vicariance-dépendant incluant des fossiles datés et la fragmentation du Gondwana. Les abscisses représentent le temps en millions d’années avant le présent. Les intervalles de confiance des nœuds clefs sont marqués par des boîtes bleues.\n\n\n\nQ9 : Quels sont les deux types d’informations utilisés pour calibrer temporellement cet arbre ? En quoi sont-elles complémentaires ? Sont-elles suffisantes pour calibrer l’entièreté de l’arbre ?\n\n\n\n\n\n\nRéponse 9\n\n\n\n\n\nLes deux types d’informations utilisés sont les fossiles datés (par datation relatives ou absolues) et certains évènements géologiques datés et corrélés à des évènements de spéciation ou de divergence. Ces informations permettent de placer des “points d’ancrages” en datant certains nœuds de la phylogénie, avec une incertitude, mais il faut encore associer une date aux autres points.\nC’est avec des modèles d’évolution moléculaires que l’on peut dater les autres noeuds de l’arbre. On peut citer le plus simple et connu, le modèle de Jukes-Cantor qui considère des taux de substitutions égaux entre toutes les bases azotées, une indépendances des sites de substitution et des fréquences nucléotidiques égales.\n\n\n\nQ10 : Interpréter le Document 2.\n\n\n\n\n\n\nRéponse 10\n\n\n\n\n\nPas fait en TD."
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html",
    "title": "TD Biodiversité",
    "section": "",
    "text": "Dans ce TP/TD, nous allons utiliser le language de programmation R et depuis RStudio, un Environnement de Développmenet Intégré (IDE). Pour l’installation de R et Rstudio, le plus simple est encore de se rendre directement sur le site de RStudio et de se laisser guider.\nLa première étape est d’installer R, ici, le site de RStudio nous redirige vers la page d’accueil du CRAN (The Comprehensive R Archive Network), une archive en ligne qui liste les différentes distributions de R dans sa version la plus récente.\nIci, je vous laisse choisir la version qui correspond à votre système d’exploitation. Si vous avez un ancien système d’exploitation, il sera peut-être nécessaire d’installer une ancienne distribution de R."
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#chargement-des-packages",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#chargement-des-packages",
    "title": "TD Biodiversité",
    "section": "Chargement des packages",
    "text": "Chargement des packages\nUne fois un package installé, vous devriez le voir apparaître dans l’onglet “Packages” de la fenêtre en bas à droite de RStudio (par défaut). Une manière de charger manuellement un package est de cocher la case tout à gauche qui lui est associée, sinon on peut utiliser la fonction library() :\n\n\nAfficher le code\n# For data manipulation\nlibrary(here)\nlibrary(tidyverse)\nlibrary(rentrez)\n\n# For Phylogenetics\nlibrary(ape)\nlibrary(msa)\nlibrary(msaR)\nlibrary(phangorn)\n\n# For visualization\nlibrary(ggtree)\nlibrary(viridis)\n\n\nPour le beau geste, une version plus compacte :\nC’est aussi l’occasion de faire une révision sur les objets dans R et de découvrir l’opérateur pipe |&gt;.\nDeuxième point, la fonction lapply(). Tapez ?lapply dans la console ou utilisez la touche F1 avec le curseur de saisie sur la fonction depuis la console, cette commande appelle l’aide de R pour une fonction donnée. Toutes les fonctions, qu’elles soient dans R de base ou dans un package ont une aide (plus ou moins garnie…).\nQuel est l’intérêt de la famille de fonctions apply ? (5 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#chargement-des-fonctions-externes",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#chargement-des-fonctions-externes",
    "title": "TD Biodiversité",
    "section": "Chargement des fonctions externes",
    "text": "Chargement des fonctions externes\nPour nous simplifier la tâche, j’ai préparé quelques fonctions en avance que nous allons charger avec la fonction source().\nC’est aussi l’occasion de vous présenter le package here et l’organisation de son code en “Projets” via RStudio.\n\n\nAfficher le code\nsource(here(\"functions\", \"tidy_functions.R\"))\n\n\nLors de la création d’un “projet” RStudio, un dossier de travail est créé. Prenons l’exemple de celui-ci, ce dossier contient plusieurs fichiers : - TD_Biodiversite.Rproj - .RData - .Rhistory\nCes fichiers existent dans tous les projets RStudio. Quant aux dossiers et fichiers .qmd, ils sont propres à ce projet.\nCe fichier de travail est un “Quarto MarkDown”, c’est un fichier texte dans lequel se mélangent blocs de code et texte mis en page. Quarto est développé par Posit, la société qui développe Rstudio et le Tidyverse dont nous parlerons plus tard."
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#chargement-des-données",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#chargement-des-données",
    "title": "TD Biodiversité",
    "section": "Chargement des données",
    "text": "Chargement des données\nCharger le fichier data/usflu.annot.csv avec la fonction read_csv() et le visualiser. (5 minutes)\n\n\nAfficher le code\nannotations &lt;- read_csv(\n  file           = here(\"data\", \"usflu.annot.csv\"),\n  show_col_types = FALSE\n) |&gt; select(c(-1))\n\nview(annotations)\n\n\nAller sur GenBank et entrer un numéro d’accès dans la barre de recherche. À quoi correspond cette séquence ?\nPourquoi l’indication “Segment 4” ?\nÀ quoi correspond la protéine codée par ce gène ? Quel est le rapport avec le nom du variant ?\nPourqu’oi s’intéresser à cette séquence en particulier ? (10 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#récupération-des-séquences-par-lot",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#récupération-des-séquences-par-lot",
    "title": "TD Biodiversité",
    "section": "Récupération des séquences par lot",
    "text": "Récupération des séquences par lot\nNous allons télécharger les séquences correspondantes depuis Genbank avec le package rentrez (ne pas faire tourner le bloc sauf avec une bonne connexion internet).\n\n\nAfficher le code\nannotations |&gt;\n  mutate(\"sequences\" = Vectorize(Get_sequence)(accession)) |&gt; \n  select(c(accession, sequences)) |&gt; \n  write_to_fasta(path = here(\"output\", \"usflu_sequences.fasta\"))\n\n\nCe bloc de code utilise la fonction Get_sequence() que j’ai codée et que nous avons chargée avec la fonction source() plus tôt. vous êtes peut-être curieux de savoir à quoi elle ressemble !\nRien de plus simple, comme pour l’aide vous pouvez utiliser la touche F2 ou taper View(Get_sequence) dans la console R.\nCette fonction se base sur la fonction entrez_fetch() du package rentrez. Que permet-elle de faire ? (5 minutes)\nDans le bloc de code précédent, nous avons sauvegardé le résultat de l’opération dans le fichier output/usflu_sequences.fasta. Ouvrez le manuellement ou grace à la commande suivante :\n\n\nAfficher le code\nshell(here(\"output\", \"usflu_sequences.fasta\"))"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-la-matrice-de-distances",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-la-matrice-de-distances",
    "title": "TD Biodiversité",
    "section": "Génération de la matrice de distances",
    "text": "Génération de la matrice de distances\nNous allons générer une matrice des distances à partir de nos alignements à l’aide la fonction dist.dna(). Ouvrir l’aide de cette fonction.\nCombien de modèles de substitution sont disponibles ? Comparer à la fonction dist.ml(). Aller sur ce lien (et celui-ci pour approfondir) et regarder les différents modèles.\nQuelles sont les différences entre ces modèles ? Nous allons utiliser le modèle TN93, pourquoi ce nom ? Quelles sont ses particularités ? Utiliser la fonction dist.dna() pour générer une matrice de distance. (5 minutes)\n\n\nAfficher le code\nalignment_BIN &lt;- msaConvert(alignment, type = \"ape::DNAbin\") \ndistance_matrix &lt;- dist.dna(alignment_BIN, model = \"TN93\")\n\n\nNous allons visualiser la matrice de distance avec ggplot2, un des nombreux packages composant le Tidyverse. Décrire la structure de cette portion de code. (5 minutes)\n\n\nAfficher le code\ndistance_matrix |&gt;\n  as.matrix() |&gt;\n  as.data.frame.table() |&gt;\n  ggplot(mapping = aes(x = Var1, y = Var2, fill = Freq)) +\n  geom_raster() +\n  scale_fill_viridis(name = \"Distance\") +\n  scale_x_discrete(position = \"top\") +\n  scale_y_discrete(limits = rev) +\n  ggtitle(\"Heatmap de la matrice des distances\") +\n  guides(x = guide_axis(angle = 90)) +\n  theme(axis.title = element_blank())\n\n\n\n\n\n\n\n\n\nPourquoi les valeurs en diagonale de la matrice sont nulles ? Identifiez-vous des tendances ? (5 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-et-visualisation-de-larbre-par-upgma",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-et-visualisation-de-larbre-par-upgma",
    "title": "TD Biodiversité",
    "section": "Génération et visualisation de l’arbre par UPGMA",
    "text": "Génération et visualisation de l’arbre par UPGMA\nGénérer et visualiser un arbre avec l’algorithme UPGMA à l’aide des fonction upgma() et plot(). Commenter cet arbre. (5 minutes)\n\n\nAfficher le code\nUPGMA_tree &lt;- upgma(distance_matrix)\nplot(UPGMA_tree, main = \"Arbre UPGMA\", cex = .6)\n\n\n\n\n\n\n\n\n\nAfficher le code\n# ggtree(UPGMA_tree) + geom_tiplab() + ggtitle(\"Arbre UPGMA\")"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-par-neighbour-joining",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-par-neighbour-joining",
    "title": "TD Biodiversité",
    "section": "Génération de l’arbre par Neighbour-Joining",
    "text": "Génération de l’arbre par Neighbour-Joining\nOuvrir l’aide de la fonction NJ(). Générer l’arbre et le visualiser avec la fonction plot().\n\n\nAfficher le code\nNJ_tree &lt;- distance_matrix |&gt; NJ()\nplot(NJ_tree)\n\n\n\n\n\n\n\n\n\nNous allons en profiter pour explorer la structure des arbres phylogénétiques en tant qu’objet sur R.\nPour commencer, explorer la structure de l’objet NJ_tree à l’aide de la fonction class() et de l’opérateur $\nLire la documentation de la fonction read.tree.\nEnregistrer l’arbre dans un fichier .txt à l’aide de la fonction ape::write.tree(). Comment est structuré ce fichier texte ?\nUtiliser les fonctions plot() et nodelabel() pour afficher l’arbre et les numéros des nœuds. (10 minutes)\n\n\nAfficher le code\nclass(NJ_tree)\n\n\n[1] \"phylo\"\n\n\nAfficher le code\nNJ_tree\n\n\n\nPhylogenetic tree with 80 tips and 78 internal nodes.\n\nTip labels:\n  CY013200, CY013781, CY012128, CY013613, CY012160, CY012272, ...\n\nUnrooted; includes branch length(s).\n\n\nAfficher le code\nNJ_tree |&gt; ape::write.tree(here(\"output\", \"NJ_tree.txt\"))\nplot(NJ_tree, cex = .6)\nnodelabels(frame = \"none\", cex = .6)\n\n\n\n\n\n\n\n\n\nNous allons voir comment visualiser ce même arbre en utilisant le package ggtree.\nCommenter le bloc de code suivant. Cette représentation vous semble-t-elle pertinente pour cette méthode ? (5 minutes)\n\n\nAfficher le code\nggtree(NJ_tree) + geom_tiplab() + geom_nodelab() + ggtitle(\"NJ non raciné\")\n\n\n\n\n\n\n\n\n\nAjoutons des annotations à cet arbre :\n\n\nAfficher le code\nggtree(NJ_tree, layout = \"circular\") %&lt;+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  ggtitle(\"NJ non raciné\") +\n  theme(legend.position = \"right\")\n\n\n\n\n\n\n\n\n\nA quoi correspondent les couleurs des feuilles de l’arbre ?\nNous allons raciner l’arbre de manière arbitraire. À partir de la figure précédente, quelle séquence vous semble pertinente pour raciner l’arbre ?\nRaciner l’arbre à l’aide de la fonction root(). (5 minutes)\n\n\n\nAfficher le code\nNJ_tree_rooted &lt;- NJ_tree |&gt; root(outgroup = \"CY012128\") |&gt; ladderize()\nggtree(NJ_tree_rooted) %&lt;+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  ggtitle(\"NJ raciné\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n\n\n! The tree contained negative edge lengths. If you want to ignore the edges,\nyou can set `options(ignore.negative.edge=TRUE)`, then re-run ggtree.\n\n\n\n\n\n\n\n\n\nCommenter cet arbre. (5 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#quelle-méthode-choisir",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#quelle-méthode-choisir",
    "title": "TD Biodiversité",
    "section": "Quelle méthode choisir ?",
    "text": "Quelle méthode choisir ?\nOn va se servir de la matrice de distance d’origine pour tester l’adéquation de la méthode choisie pour reconstruire l’arbre aux données de départ.\n\n\nAfficher le code\ndata_NJ &lt;- data.frame(\n    x = as.vector(distance_matrix),\n    y = NJ_tree_rooted |&gt; cophenetic() |&gt; as.dist() |&gt; as.vector()\n)\n\ncorcoeff &lt;- cor(data_NJ$x, data_NJ$y)^2\n\nggplot(data = data_NJ, mapping = aes(x = x, y = y)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", color = \"red\", size = .8) +\n  annotate(\"text\", x = .025, y = .055, color = \"red\",\n    label = paste0(\"Coefficient de correlation = \", as.character(corcoeff))) +\n  ggtitle(\"Est-ce que le NJ est approprié ?\") +\n  xlab(\"Distances par paires d'origine\") +\n  ylab(\"Distances par paires de l'arbre\") +\n  theme_bw()\n\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nLire l’aide de la fonction cophenetic(). Quelle valeur calcule-t-elle ? Quel type d’objet renvoie-t-elle ?\nQue représente ce graphique ? Comment l’interpréter ?\nComment est calculé le coefficient de corrélation ? (10 minutes)\n\nRecommençons avec l’arbre généré par UPGMA :\n\n\nAfficher le code\ndata_UPGMA &lt;- data.frame(\n    x = as.vector(distance_matrix),\n    y = UPGMA_tree |&gt; cophenetic() |&gt; as.dist() |&gt; as.vector()\n)\nggplot(\n  data = data_UPGMA,\n  mapping = aes(x = x, y = y)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"red\") +\n  ggtitle(\"Est-ce que l'UPGMA est appropriée ?\") +\n  xlab(\"Distances par paires d'origine\") +\n  ylab(\"Distances par paires de l'arbre\") +\n  theme_bw()\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nAfficher le code\ncor(data_UPGMA$x, data_UPGMA$y)^2\n\n\n[1] 0.7393009\n\n\nQu’en concluez-vous sur cette méthode par rapport au Neighbour-Joining ? (5 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#bootstrap",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#bootstrap",
    "title": "TD Biodiversité",
    "section": "Bootstrap",
    "text": "Bootstrap\nRappeler le principe du Bootstrap.\nÀ quoi sert-il dans ce contexte ? (5 minutes)\n\nCalcul des valeurs de Bootstrap\nNous allons générer les indices de bootstrap pour chaque nœud de l’arbre.\nCommenter le bloc de code suivant :\n\n\nAfficher le code\nbootstrap_rooted_NJ &lt;- boot.phylo(\n  NJ_tree_rooted,\n  alignment_BIN,\n  \\(x) {x |&gt;\n      dist.dna(model = \"TN93\") |&gt;\n      nj() |&gt; \n      root(outgroup = \"CY012128\")\n  }\n)\n\n\n\nRunning bootstraps:       100 / 100\nCalculating bootstrap values... done.\n\n\nAfficher le code\nNJ_tree_rooted$node.label &lt;- bootstrap_rooted_NJ\n\n\n\n\nImpression de l’arbre bootstrappé\nNous allons afficher l’arbre précédent avec les valeurs de bootstrap que nous venons de calculer :\n\n\nAfficher le code\noptions(ignore.negative.edge=TRUE)\nggtree(NJ_tree_rooted) %&lt;+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  geom_label2(\n    aes(\n      subset = !isTip,\n      label = label,\n    )\n  ) +\n  ggtitle(\"NJ raciné avec Bootstrap\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n\n\n\n\n\n\n\n\n\nCommenter cet arbre. Comment améliorer cet arbre en considérant les valeurs de bootstrap ? (5 minutes)\n\n\nOn retire les noeuds faibles\nCommenter le bloc de code suivant :\n\n\nAfficher le code\nNJ_tree_rooted_collapsed &lt;- NJ_tree_rooted\ntoCollapse &lt;- match(\n  which(bootstrap_rooted_NJ &lt; 70) + length(NJ_tree_rooted$tip.label),\n NJ_tree_rooted$edge[, 2]\n)\nNJ_tree_rooted_collapsed$edge.length[toCollapse] &lt;- 0\nNJ_tree_rooted_collapsed &lt;- di2multi(NJ_tree_rooted_collapsed, tol = 0.00001)\n\n\nAffichons notre nouvel arbre :\n\n\nAfficher le code\nggtree(NJ_tree_rooted_collapsed) %&lt;+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  geom_label2(\n    aes(\n      subset = !isTip,\n      label = label,\n    )\n  ) +\n  ggtitle(\"NJ raciné avec Bootstrap et sans les noeuds faibles\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n\n\n\n\n\n\n\n\n\nLe comparer au précédent, comment a-t-il été modifié ? (5 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#conversion-de-lalignement-dans-le-format-phydat",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#conversion-de-lalignement-dans-le-format-phydat",
    "title": "TD Biodiversité",
    "section": "Conversion de l’alignement dans le format phyDat",
    "text": "Conversion de l’alignement dans le format phyDat\n\n\nAfficher le code\nalignment_phyDat &lt;- alignment |&gt; msaConvert(type = \"phangorn::phyDat\")\nclass(alignment_phyDat)\n\n\n[1] \"phyDat\""
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-initial",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-initial",
    "title": "TD Biodiversité",
    "section": "Génération de l’arbre initial",
    "text": "Génération de l’arbre initial\nGénérons un arbre par Neighbour-Joining qui permettra d’initialiser l’algorithme de maximum de parcimonie.\n\n\nAfficher le code\nMP_tree_init &lt;- alignment_BIN |&gt; dist.dna(model = \"TN93\") |&gt; NJ()"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-le-plus-parcimonieux",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-le-plus-parcimonieux",
    "title": "TD Biodiversité",
    "section": "Génération de l’arbre le plus parcimonieux",
    "text": "Génération de l’arbre le plus parcimonieux\nUtiliser la fonction parsimony() pour calculer le score de parcimonie de l’arbre initial.\n\n\nAfficher le code\nparsimony(MP_tree_init, alignment_phyDat)\n\n\n[1] 422\n\n\nUtiliser la fonction optim.parsimony() pour générer l’arbre le plus parcimonieux.\n\n\nAfficher le code\nMP_tree &lt;- optim.parsimony(MP_tree_init, alignment_phyDat)\n\n\nFinal p-score 420 after  2 nni operations \n\n\nAfficher le code\nrm(MP_tree_init)\nMP_tree\n\n\n\nPhylogenetic tree with 80 tips and 76 internal nodes.\n\nTip labels:\n  CY013200, CY013781, CY012128, CY013613, CY012160, CY012272, ...\n\nUnrooted; no branch length.\n\n\nComparer les scores de parcimonie des deux arbres.\n\n\nAfficher le code\nggtree(MP_tree, layout = \"circular\") %&lt;+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  ggtitle(\"Arbre maximum de parcimonie\") +\n  theme(legend.position = \"right\")\n\n\n\n\n\n\n\n\n\nCommenter l’arbre généré.\nComment expliquer la similarité avec les arbres précédents ? (10 minutes)"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#initialisation",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#initialisation",
    "title": "TD Biodiversité",
    "section": "Initialisation",
    "text": "Initialisation\nSimilairement à la méthode du maximum de parcimonie, la méthode doit être initialisée avec un arbre :\n\n\nAfficher le code\nML_tree_init &lt;- alignment_BIN |&gt; dist.dna(model = \"TN93\") |&gt; NJ()\n\n\n\nCalcul de la vraisemblance de l’arbre initial\nUtiliser la fonction pml() pour calculer la vraisemblance de l’arbre initial avec le paramètre k = 4. Ce paramètre décrit le nombre de classes de vitesses évolutives utilisées dans le modèle, la valeur k = 4 est une valeur par défaut courante.\n\n\nAfficher le code\npml(ML_tree_init, alignment_phyDat, k = 4)\n\n\nmodel: JC+G(4) \nloglikelihood: -5641.785 \nunconstrained loglikelihood: -4736.539 \nModel of rate heterogeneity: Discrete gamma model\nNumber of rate categories: 4 \nShape parameter: 1 \n       Rate Proportion\n1 0.1369538       0.25\n2 0.4767519       0.25\n3 1.0000000       0.25\n4 2.3862944       0.25\n\nRate matrix:\n  a c g t\na 0 1 1 1\nc 1 0 1 1\ng 1 1 0 1\nt 1 1 1 0\n\nBase frequencies:  \n   a    c    g    t \n0.25 0.25 0.25 0.25 \n\n\nLa fonction a bien tourné mais elle est sensible à la nature des données, on va donc vérifier que le jeu de données est bien propre :\n\n\nAfficher le code\nalignment_phyDat |&gt; as.character() |&gt; table()\n\n\n\n    -     a     c     g     k     m     r     s     t     w \n  147 45595 27170 30613     1     2     1     1 32549     1 \n\n\nCertains caractères de nos séquences ne correspondent pas aux bases azotées traditionnelles !\nLire cette page et identifier à quoi correspondent les lettres différentes de a, t, c et g. À quoi correspondent les '-' ? (5 minutes).\n\nEnregistrons leur position dans un objet :\n\n\nAfficher le code\nna.posi &lt;- which(\n  apply(\n    as.character(alignment_BIN),\n    2,\n    \\(x) any(!x %in% c(\"a\",\"t\",\"g\",\"c\"))\n  )\n)\n\n\nVoyons la distribution de ces lettres :\nCommenter le bloc ce code ci-après. (5 minutes)\n\n\nAfficher le code\napply(\n  as.character(alignment_BIN),\n  2,\n  \\(x) sum(!x %in% c(\"a\",\"t\",\"g\",\"c\"))\n) |&gt;\n  plot(\n    type = \"l\",\n    col  = \"blue\",\n    xlab = \"Position in HA segment\",\n    ylab = \"Number of NAs\"\n  )\n\n\n\n\n\n\n\n\n\nRetirons les lettres différentes de a, t, c et g et vérifions que ça a bien fonctionné :\n\n\nAfficher le code\nalignment_cropped &lt;- alignment_BIN[, -na.posi]\nalignment_cropped |&gt; as.character() |&gt; table()\n\n\n\n    a     c     g     t \n43402 25104 28828 30346 \n\n\nReconvertissons le jeu de donné trié au bon format :\n\n\nAfficher le code\nalignment_cropped_phyDat &lt;- as.phyDat(alignment_cropped)\n\n\nRegénérer l’arbre d’initialisation avec notre jeu de donnée nettoyé. (5 minutes)\n\n\nAfficher le code\nML_tree_init &lt;- alignment_cropped |&gt; dist.dna(model = \"TN93\") |&gt; NJ()\nML_tree_init_L &lt;- pml(ML_tree_init, alignment_cropped_phyDat, k = 4)\nML_tree_init_L\n\n\nmodel: JC+G(4) \nloglikelihood: -5184.119 \nunconstrained loglikelihood: -4043.367 \nModel of rate heterogeneity: Discrete gamma model\nNumber of rate categories: 4 \nShape parameter: 1 \n       Rate Proportion\n1 0.1369538       0.25\n2 0.4767519       0.25\n3 1.0000000       0.25\n4 2.3862944       0.25\n\nRate matrix:\n  a c g t\na 0 1 1 1\nc 1 0 1 1\ng 1 1 0 1\nt 1 1 1 0\n\nBase frequencies:  \n   a    c    g    t \n0.25 0.25 0.25 0.25"
  },
  {
    "objectID": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-le-plus-vraisemblable",
    "href": "Teaching/TD_Biodiversite/TD_Biodiversite.html#génération-de-larbre-le-plus-vraisemblable",
    "title": "TD Biodiversité",
    "section": "Génération de l’arbre le plus vraisemblable",
    "text": "Génération de l’arbre le plus vraisemblable\nUtiliser la fonction optim.pml() pour générer l’arbre optimal avec les paramètres model = \"GTR\", inv = .2, optNni = TRUE, optBf = TRUE, optQ = TRUE, optGamma = TRUE, ce qui correspond à utiliser un modèle GTR + \\(\\Gamma\\)(4) + I (Generalised time reversible + \\(\\Gamma\\)(4) + Invariants) très standard pour ce genre d’application. Il est également possible d’utiliser la fonction modelTest() pour choisir un modèle approprié automatiquement.\n\n\nAfficher le code\nML_tree &lt;- optim.pml(\n  ML_tree_init_L,\n  model    = \"GTR\",\n  inv      = .2,\n  optNni   = TRUE,\n  optBf    = TRUE,\n  optQ     = TRUE,\n  optGamma = TRUE\n)\n\n\noptimize edge weights:  -5139.288 --&gt; -5121.539 \noptimize rate matrix:  -5121.539 --&gt; -4933.61 \noptimize shape parameter:  -4933.61 --&gt; -4919.39 \noptimize edge weights:  -4919.39 --&gt; -4919.078 \noptimize topology:  -4919.078 --&gt; -4915.934  NNI moves:  2 \noptimize rate matrix:  -4915.934 --&gt; -4915.899 \noptimize shape parameter:  -4915.899 --&gt; -4915.898 \noptimize edge weights:  -4915.898 --&gt; -4915.898 \noptimize topology:  -4915.898 --&gt; -4915.898  NNI moves:  0 \noptimize rate matrix:  -4915.898 --&gt; -4915.898 \noptimize shape parameter:  -4915.898 --&gt; -4915.898 \noptimize edge weights:  -4915.898 --&gt; -4915.898 \n\n\nAfficher le code\nML_tree\n\n\nmodel: GTR+G(4) \nloglikelihood: -4915.898 \nunconstrained loglikelihood: -4043.367 \nModel of rate heterogeneity: Discrete gamma model\nNumber of rate categories: 4 \nShape parameter: 0.2826837 \n         Rate Proportion\n1 0.003996013       0.25\n2 0.091111301       0.25\n3 0.565542826       0.25\n4 3.339349861       0.25\n\nRate matrix:\n         a          c         g         t\na 0.000000  2.3849152 8.3016092  0.863043\nc 2.384915  0.0000000 0.1472685 10.080389\ng 8.301609  0.1472685 0.0000000  1.000000\nt 0.863043 10.0803894 1.0000000  0.000000\n\nBase frequencies:  \n        a         c         g         t \n0.3398051 0.1966759 0.2259102 0.2376088 \n\n\nque dire dees pramètres optimaux obtenus ? (5 minutes)\nComparons notre arbre optimal avec l’arbre initial généré par Neighbour-Joining :\n\n\nAfficher le code\nanova(ML_tree_init_L, ML_tree)\n\n\nLikelihood Ratio Test Table\n  Log lik.  Df Df change Diff log lik. Pr(&gt;|Chi|)    \n1  -5184.1 158                                       \n2  -4915.9 166         8        536.44  &lt; 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nAfficher le code\nAIC(ML_tree_init_L, ML_tree)\n\n\n                df      AIC\nML_tree_init_L 158 10684.24\nML_tree        166 10163.80\n\n\nLire l’aide de la fonction AIC. À quoi sert le Critère d’Information d’Akaike ? Pourquoi utiliser l’ANOVA et l’AIC ? (5 minutes)\nAffichons notre super arbre !\n\n\nAfficher le code\nML_tree_rooted &lt;- ML_tree$tree |&gt; root(outgroup = \"CY012128\") |&gt; ladderize()\nggtree(ML_tree_rooted) %&lt;+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  geom_label2(\n    aes(\n      subset = !isTip,\n      label = label,\n    )\n  ) +\n  ggtitle(\"Maximum de vraisemblance\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n\n\n\n\n\n\n\n\n\nObservez-voius des différences aves les arbres précédents ? (5 minutes)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Personnal_website",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nW.I.P."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "W.I.P."
  },
  {
    "objectID": "Teaching/PCA_Class/PCA_Class.html",
    "href": "Teaching/PCA_Class/PCA_Class.html",
    "title": "PCA_Class",
    "section": "",
    "text": "Source : https://medium.com/intuition/mathematical-understanding-of-principal-component-analysis-6c761004c2f8\nConsidérons une matrice \\(x\\) de taille \\(n \\times p\\) représentant \\(n\\) individus et leurs \\(p\\) paramètres associés :\n\n\n\n\nTable 1: Extrait de traits de 50 individus\n\n\n\n\n\n\nIndividus\nTrait 1\nTrait 2\n\n\n\n\n1\n5.512312\n12.090915\n\n\n2\n5.510266\n12.465172\n\n\n3\n5.484722\n9.812306\n\n\n4\n4.745643\n9.865250\n\n\n5\n5.386212\n11.189728\n\n\n6\n5.269030\n10.080999\n\n\n\n\n\n\n\n\nOn peut également considérer qu’il s’agit de \\(n\\) réalisations de \\(p\\) variables aléatoires \\(X_{1}, \\dots, X_{p}\\).\nAinsi, une ligne de \\(x\\) correspond à un individu que l’on représente par le vecteur ligne \\(x_{i}\\) avec ses \\(p\\) paramètres :\n\\[\nx_{i} = \\begin{bmatrix} x_{1} \\dots x_{p}\\end{bmatrix}_{i} \\text{ et } x_{i}^T = \\begin{bmatrix}\n      x_{1}\\\\\n      \\vdots \\\\\n      x_{p}\n    \\end{bmatrix}_{i} \\text{ sa transposée.}\n\\] On peut représenter le jeu de données, la matrice \\(x\\), par \\(n\\) points dans un espace à \\(p\\) dimensions comme dans notre exemple :\n\n\n\n\n\n\n\n\nFigure 1: Biplot des deux traits d’intérêt\n\n\n\n\n\nPour faciliter les calculs, on centre et réduit les \\(X_{p}\\) variables aléatoires :\n\n\n\n\n\n\n\n\nFigure 2: Biplot des deux traits d’intérêt centrés et réduits\n\n\n\n\n\nOn cherche à trouver un axe représenté par un vecteur \\(w\\) de l’espace des paramètres, donc à \\(p\\) dimensions, tel qu’il maximise la variance du jeu de données, ou nuage de point, projetée sur celui-ci.\nC’est aussi équivalent à minimiser la somme du carré des résidus :\n\n\n\n\n\n\n\n\nFigure 3: Equivalence entre MSE et Variance\n\n\n\n\nPosons le problème mathématiquement :\n\n\n\n\n\n\nFigure 4: Projection de \\(x_{i}\\) sur \\(w\\)\n\n\n\nSoit \\(x_{i}\\) une composante de \\(x\\) et \\(w\\) un vecteur unitaire (donc \\(\\|w\\| = 1\\) par définition). On a :\n\\[\n\\text{cos}(\\theta) = \\frac{x_{i} \\cdot w}{\\|x_{i}\\|\\|w\\|}\n\\]\nTel que la projection orthogonale de \\(x_{i}\\) sur \\(w\\) est de norme :\n\\[\n\\|x_{i}\\| \\text{cos}(\\theta) = \\|x_{i}\\|  \\frac{x_{i} \\cdot w}{\\|x_{i}\\|\\|w\\|} = x_{i} \\cdot w\n\\]\nOn a donc le résidu associé :\n\\[\\begin{align}\n\n\\| x_{i} - (x_{i} \\cdot w)w \\|^2 &= (x_{i} - (x_{i} \\cdot w)w) \\cdot  (x_{i} - (x_{i} \\cdot w)w) \\\\\n                                 &= \\|x_{i}\\|^2 - 2(w \\cdot x_{i})^2 + (x_{i} \\cdot w)^2w \\cdot w \\\\\n                                 &= x_{i} \\cdot x_{i} - (w \\cdot x_{i})^2\n\n\\end{align}\\]\nOn a donc la somme des rédisus ou Mean Squared Error (MSE)\n\\[\\begin{align}\n\n\\text{MSE}(w) &= \\frac{1}{n} \\sum_{i = 1}^n(\\|x_{i}\\|^2 - (w \\cdot x_{i})^2) \\\\\n&= \\frac{1}{n} \\sum_{i = 1}^n\\|x_{i}\\|^2 - \\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 \\\\\n\n\\end{align}\\]\nOn veut trouver \\(w\\) tel que \\(\\text{MSE}(w)\\) soit minimale. Le premier terme est constant en fonction de \\(w\\), il reste donc à maximiser le second terme (il y a un \\(-\\) !). On remarque que le second terme peut s’écrire \\(\\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 = E\\left[(w \\cdot x_{i})^2\\right]\\) or on a la relation \\(\\text{Var}(X) = E[X^2] - E[X]^2\\) d’où l’égalite :\n\\[\\begin{align}\n\n\\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 &= (\\frac{1}{n} \\sum_{i = 1}^n w \\cdot x_{i})^2 + \\text{Var}(w \\cdot x_{i}) \\\\\n&= \\text{Var}(w \\cdot x_{i})\n\n\\end{align}\\]\nCar \\(w \\cdot x_{i} = x_{i}\\) puisque \\(w\\) est unitaire et les \\(X_{p}\\) sont centrées donc de moyennes nulles donc \\(\\frac{1}{n} \\sum_{i = 1}^n x_{i} = 0\\).\nAinsi on a :\n\\[\n\\text{MSE}(w) = \\frac{1}{n}\\sum_{i = 1}^n \\|x_{i}\\|^2 - \\text{Var}(w \\cdot x_{i})\n\\]\nMinimiser MSE revient donc à maximiser la variance des projections des \\(x_{i}\\) mais comment faire ?\nEn rappelant :\n\\[\n\\text{Var}(x_{i}) = \\frac{1}{p}x_{i}^Tx_{i} = \\frac{1}{p} \\sum_{j = 1}^px_{j, (i)}^2\n\\]\nOn obtient :\n\\[\\begin{align}\n\n\\sigma_{w}^2 = \\text{Var}(w \\cdot x_{i}) &= \\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 \\\\\n&= \\frac{1}{n}(xw)^T(xw) \\\\\n&= \\frac{1}{n}w^Tx^Txw \\\\\n\\sigma_{w}^2 &= w^Tcov_{x^T,x}w\n\n\\end{align}\\]\navec \\(cov_{x^T,x}\\) la matrice de variance-covariance des \\(X_{p}\\) variables aléatoires correspondants à nos paramètres : \\[\\begin{align}\n\ncov_{x^T,x} = \\text{Cov}\\left[x^T,x\\right] &= E\\left[(x - \\mu_{x})^T(x - \\mu_{x})\\right] \\\\\n&= E\\left[x^Tx\\right] \\text{ en centrant les } X_{p}\\\\\n\\text{En développant :} \\\\\ncov_{x^T,x} &= \\begin{bmatrix} \\text{Var}(X_{1}) & \\dots & \\text{Cov}(X_{1}, X_{p}) \\\\\n                              \\vdots & \\ddots & \\vdots \\\\\n                              \\text{Cov}(X_{p}, X_{1}) & \\dots & \\text{Var}(X_{p}) \\end{bmatrix}\n\n\\end{align}\\]\nN.B : Attention à la dimensionnalité, \\(\\frac{1}{n}x^Tx = cov_{x^T,x}\\) est une matrice de covariance (de dimension \\(p \\times p\\)) alors que \\(\\frac{1}{n}xx^T = \\frac{1}{n} \\sum_{i = 1}^nx_{i}^2\\) est un nombre (de dimension \\(1 \\times 1\\)).\nAinsi, minimiser \\(\\text{MSE}(w)\\) revient à trouver \\(w\\), vecteur unitaire, tel que \\(\\sigma_{w}^2\\) soit minimisé.\nPour minimiser \\(\\sigma_{w}^2\\), on peut utiliser l’opérateur Lagrangien avec la contrainte que \\(w\\) doit être un vecteur unitaire, c’est à dire que \\(\\|w\\| = w^Tw = 1\\) comme suit :\n\\[\\begin{align}\n\n\\mathcal{L}(w, \\lambda) &\\equiv \\sigma_{w}^2 - \\lambda(w^Tw - 1) \\\\\n\\frac{\\partial\\mathcal{L}}{\\partial \\lambda} &= (w^Tw - 1) \\\\\n\\frac{\\partial\\mathcal{L}}{\\partial w} &= 2cov_{X^T,X}w - 2\\lambda w\n\n\\end{align}\\]\nOn a donc à l’optimum, en posant les dérivées partielles nulles, le système d’équations :\n\\[\\begin{align}\n\nw^Tw&= 1 \\\\\ncov_{x^T,x}w &= \\lambda w\n\n\\end{align}\\]\nCe qui revient à trouver les valeurs et vecteurs propres de la matrice de covariance de X ! De plus le vecteur propre associé à la valeur propre la plus élevée maximisera la covariance.\nEt ça nous arrange bien car la matrice de covariance a des propriétés intéressantes : c’est une matrice carrée, positive, symétrique et inversible. Donc il existe une décomposition en valeurs propres de cette matrice tel que \\(cov_{x^T,x}\\) se factorise sous la forme :\n\\[\ncov_{x^T,x} = x^Tx = W \\Lambda W^{-1}\n\\] Avec \\(W\\), de taille \\(p \\times p\\), la matrice diagonlae des vecteurs propres et \\(\\Lambda\\), de taille \\(p \\times p\\), la matrice des valeurs propres de \\(cov_{x^T,x}\\).\nLes vecteurs propres ainsi trouvés sont tous unitaires et orthogonaux et forment une base de l’espace à \\(p\\) dimensions de départ.\nOn a alors les coordonnées de notre nuage de points initial dans le nouveau repère défini par \\(W\\) qui sont données par :\n\\[\nT = xW\n\\]\nOn appelle T la matrice des poids.\nEn pratique, la diagonalisation de \\(cov_{x^T,x}\\) est gourmande en calculs car elle nécessite le passer par l’intermédiaire \\(x^T\\). Une “astuce” informatique consiste à réaliser une décomposition en valeurs singulières de \\(x\\) tel que :\n\\[\nx = U \\Sigma V^T\n\\]\navec U une matrice unitaire (càd \\(UU^T = I\\)) de taille \\(n \\times n\\), V une matrice unitaire (càd \\(UU^T = I\\)) de taille \\(p \\times p\\) et \\(\\Sigma\\) une matrice diagonale rectangulaire de taille \\(n \\times p\\) dont les coefficients diagonaux sont les \\(\\sqrt{\\lambda_{i}}\\) non nuls.\nOn a alors la relation :\n\\[\nx^Tx = V (\\Sigma^T\\Sigma) V^T =  W \\Lambda W^{-1}\n\\]\nOn retrouve une décomposition en valeurs propres. En décomposant \\(x\\) en valeurs singulières, on s’évite de passer par le calcul de son inverse.\n\n\n\n\n\n\nFigure 5: Interprétation graphique de la Décomposition en Valeurs Singulières"
  },
  {
    "objectID": "Teaching/PCA_Class/PCA_Class.html#les-mathématiques-de-lacp",
    "href": "Teaching/PCA_Class/PCA_Class.html#les-mathématiques-de-lacp",
    "title": "PCA_Class",
    "section": "",
    "text": "Source : https://medium.com/intuition/mathematical-understanding-of-principal-component-analysis-6c761004c2f8\nConsidérons une matrice \\(x\\) de taille \\(n \\times p\\) représentant \\(n\\) individus et leurs \\(p\\) paramètres associés :\n\n\n\n\nTable 1: Extrait de traits de 50 individus\n\n\n\n\n\n\nIndividus\nTrait 1\nTrait 2\n\n\n\n\n1\n5.512312\n12.090915\n\n\n2\n5.510266\n12.465172\n\n\n3\n5.484722\n9.812306\n\n\n4\n4.745643\n9.865250\n\n\n5\n5.386212\n11.189728\n\n\n6\n5.269030\n10.080999\n\n\n\n\n\n\n\n\nOn peut également considérer qu’il s’agit de \\(n\\) réalisations de \\(p\\) variables aléatoires \\(X_{1}, \\dots, X_{p}\\).\nAinsi, une ligne de \\(x\\) correspond à un individu que l’on représente par le vecteur ligne \\(x_{i}\\) avec ses \\(p\\) paramètres :\n\\[\nx_{i} = \\begin{bmatrix} x_{1} \\dots x_{p}\\end{bmatrix}_{i} \\text{ et } x_{i}^T = \\begin{bmatrix}\n      x_{1}\\\\\n      \\vdots \\\\\n      x_{p}\n    \\end{bmatrix}_{i} \\text{ sa transposée.}\n\\] On peut représenter le jeu de données, la matrice \\(x\\), par \\(n\\) points dans un espace à \\(p\\) dimensions comme dans notre exemple :\n\n\n\n\n\n\n\n\nFigure 1: Biplot des deux traits d’intérêt\n\n\n\n\n\nPour faciliter les calculs, on centre et réduit les \\(X_{p}\\) variables aléatoires :\n\n\n\n\n\n\n\n\nFigure 2: Biplot des deux traits d’intérêt centrés et réduits\n\n\n\n\n\nOn cherche à trouver un axe représenté par un vecteur \\(w\\) de l’espace des paramètres, donc à \\(p\\) dimensions, tel qu’il maximise la variance du jeu de données, ou nuage de point, projetée sur celui-ci.\nC’est aussi équivalent à minimiser la somme du carré des résidus :\n\n\n\n\n\n\n\n\nFigure 3: Equivalence entre MSE et Variance\n\n\n\n\nPosons le problème mathématiquement :\n\n\n\n\n\n\nFigure 4: Projection de \\(x_{i}\\) sur \\(w\\)\n\n\n\nSoit \\(x_{i}\\) une composante de \\(x\\) et \\(w\\) un vecteur unitaire (donc \\(\\|w\\| = 1\\) par définition). On a :\n\\[\n\\text{cos}(\\theta) = \\frac{x_{i} \\cdot w}{\\|x_{i}\\|\\|w\\|}\n\\]\nTel que la projection orthogonale de \\(x_{i}\\) sur \\(w\\) est de norme :\n\\[\n\\|x_{i}\\| \\text{cos}(\\theta) = \\|x_{i}\\|  \\frac{x_{i} \\cdot w}{\\|x_{i}\\|\\|w\\|} = x_{i} \\cdot w\n\\]\nOn a donc le résidu associé :\n\\[\\begin{align}\n\n\\| x_{i} - (x_{i} \\cdot w)w \\|^2 &= (x_{i} - (x_{i} \\cdot w)w) \\cdot  (x_{i} - (x_{i} \\cdot w)w) \\\\\n                                 &= \\|x_{i}\\|^2 - 2(w \\cdot x_{i})^2 + (x_{i} \\cdot w)^2w \\cdot w \\\\\n                                 &= x_{i} \\cdot x_{i} - (w \\cdot x_{i})^2\n\n\\end{align}\\]\nOn a donc la somme des rédisus ou Mean Squared Error (MSE)\n\\[\\begin{align}\n\n\\text{MSE}(w) &= \\frac{1}{n} \\sum_{i = 1}^n(\\|x_{i}\\|^2 - (w \\cdot x_{i})^2) \\\\\n&= \\frac{1}{n} \\sum_{i = 1}^n\\|x_{i}\\|^2 - \\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 \\\\\n\n\\end{align}\\]\nOn veut trouver \\(w\\) tel que \\(\\text{MSE}(w)\\) soit minimale. Le premier terme est constant en fonction de \\(w\\), il reste donc à maximiser le second terme (il y a un \\(-\\) !). On remarque que le second terme peut s’écrire \\(\\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 = E\\left[(w \\cdot x_{i})^2\\right]\\) or on a la relation \\(\\text{Var}(X) = E[X^2] - E[X]^2\\) d’où l’égalite :\n\\[\\begin{align}\n\n\\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 &= (\\frac{1}{n} \\sum_{i = 1}^n w \\cdot x_{i})^2 + \\text{Var}(w \\cdot x_{i}) \\\\\n&= \\text{Var}(w \\cdot x_{i})\n\n\\end{align}\\]\nCar \\(w \\cdot x_{i} = x_{i}\\) puisque \\(w\\) est unitaire et les \\(X_{p}\\) sont centrées donc de moyennes nulles donc \\(\\frac{1}{n} \\sum_{i = 1}^n x_{i} = 0\\).\nAinsi on a :\n\\[\n\\text{MSE}(w) = \\frac{1}{n}\\sum_{i = 1}^n \\|x_{i}\\|^2 - \\text{Var}(w \\cdot x_{i})\n\\]\nMinimiser MSE revient donc à maximiser la variance des projections des \\(x_{i}\\) mais comment faire ?\nEn rappelant :\n\\[\n\\text{Var}(x_{i}) = \\frac{1}{p}x_{i}^Tx_{i} = \\frac{1}{p} \\sum_{j = 1}^px_{j, (i)}^2\n\\]\nOn obtient :\n\\[\\begin{align}\n\n\\sigma_{w}^2 = \\text{Var}(w \\cdot x_{i}) &= \\frac{1}{n} \\sum_{i = 1}^n(w \\cdot x_{i})^2 \\\\\n&= \\frac{1}{n}(xw)^T(xw) \\\\\n&= \\frac{1}{n}w^Tx^Txw \\\\\n\\sigma_{w}^2 &= w^Tcov_{x^T,x}w\n\n\\end{align}\\]\navec \\(cov_{x^T,x}\\) la matrice de variance-covariance des \\(X_{p}\\) variables aléatoires correspondants à nos paramètres : \\[\\begin{align}\n\ncov_{x^T,x} = \\text{Cov}\\left[x^T,x\\right] &= E\\left[(x - \\mu_{x})^T(x - \\mu_{x})\\right] \\\\\n&= E\\left[x^Tx\\right] \\text{ en centrant les } X_{p}\\\\\n\\text{En développant :} \\\\\ncov_{x^T,x} &= \\begin{bmatrix} \\text{Var}(X_{1}) & \\dots & \\text{Cov}(X_{1}, X_{p}) \\\\\n                              \\vdots & \\ddots & \\vdots \\\\\n                              \\text{Cov}(X_{p}, X_{1}) & \\dots & \\text{Var}(X_{p}) \\end{bmatrix}\n\n\\end{align}\\]\nN.B : Attention à la dimensionnalité, \\(\\frac{1}{n}x^Tx = cov_{x^T,x}\\) est une matrice de covariance (de dimension \\(p \\times p\\)) alors que \\(\\frac{1}{n}xx^T = \\frac{1}{n} \\sum_{i = 1}^nx_{i}^2\\) est un nombre (de dimension \\(1 \\times 1\\)).\nAinsi, minimiser \\(\\text{MSE}(w)\\) revient à trouver \\(w\\), vecteur unitaire, tel que \\(\\sigma_{w}^2\\) soit minimisé.\nPour minimiser \\(\\sigma_{w}^2\\), on peut utiliser l’opérateur Lagrangien avec la contrainte que \\(w\\) doit être un vecteur unitaire, c’est à dire que \\(\\|w\\| = w^Tw = 1\\) comme suit :\n\\[\\begin{align}\n\n\\mathcal{L}(w, \\lambda) &\\equiv \\sigma_{w}^2 - \\lambda(w^Tw - 1) \\\\\n\\frac{\\partial\\mathcal{L}}{\\partial \\lambda} &= (w^Tw - 1) \\\\\n\\frac{\\partial\\mathcal{L}}{\\partial w} &= 2cov_{X^T,X}w - 2\\lambda w\n\n\\end{align}\\]\nOn a donc à l’optimum, en posant les dérivées partielles nulles, le système d’équations :\n\\[\\begin{align}\n\nw^Tw&= 1 \\\\\ncov_{x^T,x}w &= \\lambda w\n\n\\end{align}\\]\nCe qui revient à trouver les valeurs et vecteurs propres de la matrice de covariance de X ! De plus le vecteur propre associé à la valeur propre la plus élevée maximisera la covariance.\nEt ça nous arrange bien car la matrice de covariance a des propriétés intéressantes : c’est une matrice carrée, positive, symétrique et inversible. Donc il existe une décomposition en valeurs propres de cette matrice tel que \\(cov_{x^T,x}\\) se factorise sous la forme :\n\\[\ncov_{x^T,x} = x^Tx = W \\Lambda W^{-1}\n\\] Avec \\(W\\), de taille \\(p \\times p\\), la matrice diagonlae des vecteurs propres et \\(\\Lambda\\), de taille \\(p \\times p\\), la matrice des valeurs propres de \\(cov_{x^T,x}\\).\nLes vecteurs propres ainsi trouvés sont tous unitaires et orthogonaux et forment une base de l’espace à \\(p\\) dimensions de départ.\nOn a alors les coordonnées de notre nuage de points initial dans le nouveau repère défini par \\(W\\) qui sont données par :\n\\[\nT = xW\n\\]\nOn appelle T la matrice des poids.\nEn pratique, la diagonalisation de \\(cov_{x^T,x}\\) est gourmande en calculs car elle nécessite le passer par l’intermédiaire \\(x^T\\). Une “astuce” informatique consiste à réaliser une décomposition en valeurs singulières de \\(x\\) tel que :\n\\[\nx = U \\Sigma V^T\n\\]\navec U une matrice unitaire (càd \\(UU^T = I\\)) de taille \\(n \\times n\\), V une matrice unitaire (càd \\(UU^T = I\\)) de taille \\(p \\times p\\) et \\(\\Sigma\\) une matrice diagonale rectangulaire de taille \\(n \\times p\\) dont les coefficients diagonaux sont les \\(\\sqrt{\\lambda_{i}}\\) non nuls.\nOn a alors la relation :\n\\[\nx^Tx = V (\\Sigma^T\\Sigma) V^T =  W \\Lambda W^{-1}\n\\]\nOn retrouve une décomposition en valeurs propres. En décomposant \\(x\\) en valeurs singulières, on s’évite de passer par le calcul de son inverse.\n\n\n\n\n\n\nFigure 5: Interprétation graphique de la Décomposition en Valeurs Singulières"
  },
  {
    "objectID": "Teaching/PCA_Class/PCA_Class.html#example-simple-à-trois-dimensions",
    "href": "Teaching/PCA_Class/PCA_Class.html#example-simple-à-trois-dimensions",
    "title": "PCA_Class",
    "section": "Example simple à trois dimensions",
    "text": "Example simple à trois dimensions\n\nlibrary(FactoMineR)\n\n\n\n\n\nTable 2: Extrait des valeurs des données Iris\n\n\n\n\n\n\nSpecies\nSepal.Width\nPetal.Width\nPetal.Length\n\n\n\n\nsetosa\n3.5\n0.2\n1.4\n\n\nsetosa\n3.0\n0.2\n1.4\n\n\nsetosa\n3.2\n0.2\n1.3\n\n\nsetosa\n3.1\n0.2\n1.5\n\n\nsetosa\n3.6\n0.2\n1.4\n\n\nsetosa\n3.9\n0.4\n1.7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6: Plots des valeurs de Iris\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Plots des valeurs de Iris centrées et réduites\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8: Plots des valeurs de l’ACP de Iris"
  },
  {
    "objectID": "Teaching/PCA_Class/PCA_Class.html#et-en-pratique",
    "href": "Teaching/PCA_Class/PCA_Class.html#et-en-pratique",
    "title": "PCA_Class",
    "section": "Et en pratique ?",
    "text": "Et en pratique ?\n\nlibrary(factoextra)\nlibrary(patchwork)\n\n\niris_pca &lt;- iris |&gt;\n  select(-c(Species)) |&gt;\n  PCA(\n    scale.unit = TRUE,\n    ncp        = 5,\n    graph      = FALSE\n  )\n\niris_pca\n\n**Results for the Principal Component Analysis (PCA)**\nThe analysis was performed on 150 individuals, described by 4 variables\n*The results are available in the following objects:\n\n   name               description                          \n1  \"$eig\"             \"eigenvalues\"                        \n2  \"$var\"             \"results for the variables\"          \n3  \"$var$coord\"       \"coord. for the variables\"           \n4  \"$var$cor\"         \"correlations variables - dimensions\"\n5  \"$var$cos2\"        \"cos2 for the variables\"             \n6  \"$var$contrib\"     \"contributions of the variables\"     \n7  \"$ind\"             \"results for the individuals\"        \n8  \"$ind$coord\"       \"coord. for the individuals\"         \n9  \"$ind$cos2\"        \"cos2 for the individuals\"           \n10 \"$ind$contrib\"     \"contributions of the individuals\"   \n11 \"$call\"            \"summary statistics\"                 \n12 \"$call$centre\"     \"mean of the variables\"              \n13 \"$call$ecart.type\" \"standard error of the variables\"    \n14 \"$call$row.w\"      \"weights for the individuals\"        \n15 \"$call$col.w\"      \"weights for the variables\"          \n\n\n\niris |&gt;\n  select(-c(Species)) |&gt;\n  prcomp(scale. = TRUE)\n\nStandard deviations (1, .., p=4):\n[1] 1.7083611 0.9560494 0.3830886 0.1439265\n\nRotation (n x k) = (4 x 4):\n                    PC1         PC2        PC3        PC4\nSepal.Length  0.5210659 -0.37741762  0.7195664  0.2612863\nSepal.Width  -0.2693474 -0.92329566 -0.2443818 -0.1235096\nPetal.Length  0.5804131 -0.02449161 -0.1421264 -0.8014492\nPetal.Width   0.5648565 -0.06694199 -0.6342727  0.5235971\n\n\nAide de la fonction prcomp().\nOn commence par deux types de graphiques : Un Screeplot et un cercle des corrélations.\n\n\n\n\n\n\n\n\nFigure 9: Screeplot et cercle des corrélations pour Iris\n\n\n\n\n\nLa fonction fviz_pca_var() permet de colorer les vecteurs des variables par le carré de leur cosinus avec les vecteurs propres :\n\niris_pca |&gt;\n  fviz_pca_var(\n    col.var       = \"cos2\",\n    gradient.cols = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"), \n    repel         = TRUE # Avoid text overlapping\n  )\n\n\n\n\n\n\n\n\nUne autre manière de visualiser ces contributions :\n\nlibrary(corrplot)\n\nvar &lt;- get_pca_var(iris_pca)\ncorrplot(var$cos2, is.corr = FALSE)\n\n\n\n\n\n\n\nfviz_cos2(iris_pca, choice = \"var\", axes = 1:2)\n\n\n\n\n\n\n\nfviz_contrib(iris_pca,\n             choice = \"var\",\n             axes  = 1,\n             top   = 10) + \n  fviz_contrib(iris_pca,\n               choice = \"var\",\n               axes   = 2,\n               top  = 10)\n\n\n\n\n\n\n\n\nOn peut maintenant regarder ce qu’il se passe du côté des individus :\n\niris_pca |&gt; fviz_pca_ind(\n  axes       = c(1, 2),\n  geom.ind   = \"point\",\n  mean.point = FALSE\n)\n\n\n\n\n\n\n\n\nIl semble y avoir plusieurs groupes, ajoutons une variable catégorielle pour aider à la visualisation :\n\niris_pca |&gt; fviz_pca_ind(\n  axes       = c(1, 2),\n  geom.ind   = \"point\",\n  col.ind    = iris$Species, \n  palette    = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  mean.point = FALSE\n)\n\n\n\n\n\n\n\n\nLes axes 1 et 2 de l’ACP nous permettent de distinguer clairement deux groupes qui correspondent bien à des espèces différentes.\n\niris_pca |&gt; fviz_pca_ind(\n  axes       = c(2, 3),\n  geom.ind   = \"point\",\n  col.ind    = iris$Species, \n  palette    = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  mean.point = FALSE\n)\n\n\n\n\n\n\n\niris_pca |&gt; fviz_pca_ind(\n  axes       = c(3, 4),\n  geom.ind   = \"point\",\n  col.ind    = iris$Species, \n  palette    = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\"),\n  mean.point = FALSE\n)\n\n\n\n\n\n\n\n\nPar contre les axes 2 et 3 sont moins informatifs dans ce cas, comme prédis par le screeplot."
  },
  {
    "objectID": "Teaching/PCA_Class/PCA_Class.html#a-retenir-de-lacp",
    "href": "Teaching/PCA_Class/PCA_Class.html#a-retenir-de-lacp",
    "title": "PCA_Class",
    "section": "A retenir de l’ACP",
    "text": "A retenir de l’ACP\n\nC’est une analyse exploratoire d’un jeu de données a priori corrélées, pas un test statistique. Elle permet de décrire la variance d’un jeu de données\nCette analyse permet de réduire la dimensionnalité des données et les résume par des composantes principales\nCes composantes principales sont orthogonales (i. e non corrélés) et participent de manière décroissante à la variance totale du jeu de données\nLe nouvel espace est Euclidien, on peut y mesurer des distances et des angles. Attention cependant à leur interprétation !"
  },
  {
    "objectID": "Teaching/PCA_Class/PCA_Class.html#analyses-de-la-même-famille",
    "href": "Teaching/PCA_Class/PCA_Class.html#analyses-de-la-même-famille",
    "title": "PCA_Class",
    "section": "Analyses de la même famille",
    "text": "Analyses de la même famille\nWORK IN PROGRESS"
  },
  {
    "objectID": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1.html",
    "href": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1.html",
    "title": "TD 2 de Phylogénie",
    "section": "",
    "text": "Un Xenomorphe de la saga Alien nous faisant de jolis sourires (Xenopedia)\nConnaissances travaillées :\nCompétences travaillées :"
  },
  {
    "objectID": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1.html#la-pharyngognathie-chez-les-téléostéens",
    "href": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1.html#la-pharyngognathie-chez-les-téléostéens",
    "title": "TD 2 de Phylogénie",
    "section": "La pharyngognathie chez les Téléostéens",
    "text": "La pharyngognathie chez les Téléostéens\nLes poissons Téléostéens possèdent, en plus de leurs mâchoires orales, une deuxième paire de mâchoires appelées mâchoires pharyngiennes (Figure 1).\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\nFigure 1: Diagramme des os du crâne d’un poisson Téléostéen (ici le Cichlidé Herichtys minckleyi).\nLes os de la mâchoire orale sont colorés en violet et ceux de la mâchoire pharyngienne en bleu. La barre d’échelle représente 5 mm. (Adapté d’A. Oulès)\n\n\n\nQ1 : Quel peut-être l’intérêt fonctionnel de cette seconde paire de mâchoires ?\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n(a) Mâchoires pharyngiennes d’une Murène (Mehta & Wainright 2007) DOI : 10.1038/nature06062\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n(b) Diversité des mâchoires pharyngiennes des Cichlidés (Burress 2015) DOI : 10.1111/1365-2656.12457\n\n\n\n\n\n \n\n\n\n\nFigure 2: Diversité des mâchoires pharyngiennes chez les Téléostéens\n\n\n\nQ2 : Pouvez-vous émettre une hypothèse sur l’origine développementale de ces mâchoires ?\nChez certains groupes, ce caractère est associé à de nombreuses modifications comme la fusion des demi-mâchoires pharyngiennes inférieures et une modification de la musculature associée (Figure 2). Ces modifications permettent notamment une force de mastication supérieure et l’apparition de régimes alimentaires à base d’aliments coriaces comme les molluscivores ou les corallivores, ce mode d’alimentation à partir de mâchoires pharyngiennes dérivées est appelé pharyngognathie.\n\n\n\n\n\n\nDocument 1: Impact de la pharyngognathie sur la transition de régime alimentaire chez les poissons marins. (McGee et al 2015 DOI : 10.1126/science.aab0800)\n(A) Quatre transitions vers la pharyngognathie sur une phylogénie de 851 Actinoptérygiens calibrée temporellement. (1) Les Labres (Labridae et Scaridae); (2) Les Embiotocidae; (3) Les Demoiselles (Pomacentridae); (4) Les Hemirhamphidae\n(B) Comparaison des taux de transitions de régime alimentaire vers la piscivorie (poissons non larvaires) ou vers des proies à mastication intense (détritus, plantes, proies à coquilles dures), pour des pour des poissons pharyngognathes ou non.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa construction des phylogénies calibrées (ou chronogrammes) est abordée plus en détails dans la section suivante du TD.\n\n\nQ3 : À partir du Document 1 A, décrivez l’évolution de la pharyngognathie chez les Actinoptérygiens.\nExtrait 1 : The degree of piscivory was defined as the volumetric percentage of non-larval fish in the diet, and the degree of processing-intensive prey was defined as the volumetric percentage of plants, algae, and detritus combined with the percentage of hard-shelled prey like bivalves, shelled gastropods, and hard-bodied echinoderms (i. e. no holothurian “sea cucumbers”).\nWe used the brownie.lite function in the phytools R package to test whether each diet category was best modeled as a one-rate model across the tree, or a model where rates differed between pharyngognathous and non-pharyngognathous marine fishes. There was a strong preference for a two-rate model for both fish prey (∆AICc = -293) and processing-intensive prey (∆AICc = -59). For both traits, the difference between pharyngognaths and non-pharyngognaths for the Brownian rate parameter in the two-rate model was always significant (p &lt; 0.001).\n\n\n\n\n\n\nNote\n\n\n\nAIC = Akaike Information Criterion (Critère d’information d’Akaike) est une mesure de la qualité relative d’un modèle statistique sachant un ensemble de données. Lorsque l’on estime un modèle statistique, il est possible d’augmenter la vraisemblance du modèle en ajoutant un paramètre. Le critère d’information d’Akaike prend cela en compte en pénalisant les modèles en fonction du nombre de paramètres. On choisit alors le modèle avec le critère d’information d’Akaike le plus faible.\n\n\nQ4 : Qu’est-ce qu’un mouvement Brownien ? Comment peut-il être utilisé pour modéliser l’évolution d’un trait continu ?\nQ5 : Rappeler le principe du maximum de vraisemblance. La fonction brownie.lite inclut ce principe, à votre avis, de quelle façon ?\nQ6 : Quel est le résultat obtenu à l’issue de ces tests ?\nExtrait 2 : Our Brownian rate analysis treated the percentage of either processing-intensive or fish prey as a continuous character. However, if we define each species as a prey specialist if it eats over a certain percentage of that prey in its diet, we can also analyze diet as a categorical variable using stochastic character mapping. We also used stochastic character mapping in the phytools package to examine transitions between dietary strategies. Fish were scored as processing-intensive if they had a mean value of processing-intensive prey over 25% of their diet, and as piscivorous if the mean value of non-larval fish in their diet was higher than 25%. Each fish was then scored as non-pharyngognath non-piscivore, non-pharyngognath piscivore, pharyngognath non-piscivore, and pharyngognath piscivore. We used the fitDiscrete function in the R package geiger to compare the transition rate matrix for two models of character evolution. Specifically, we tested a model with equal transition rates between non-pharyngognath non-piscivores and non-pharyngognath piscivores versus between pharyngognath non-piscivores and pharyngognath piscivores. We then compared this equal-rate model to one where the transition rates were allowed to differ. All other rates were allowed to differ. Transitions were always modeled as symmetric, i. e. equal rates into and out of a category.\nQ7 : Pourquoi recalculer les taux de transition en considérant, cette-fois, le trait comme discret ? Quelle(s) différence(s) avec le modèle précédent ?\nExtrait 3 : AIC strongly favored the model where non-pharyngognaths had a different transition rate into and out of piscivory as compared to pharyngognaths (ΔAIC = -20.3). We used a similar character mapping scheme and analysis for pharyngognathy and processing-intensive prey, and found a preference for different rates of transition within pharyngognaths as compared to non-pharyngognaths (ΔAIC = -8.6). Rates of transition between piscivory and non-piscivory were an order of magnitude higher in non-pharyngognaths (7.96e-03 vs 9.95e-04, Document 1 B). For processing-intensive prey, rates were an order of magnitude lower in non-pharyngognaths (4.03e-03 vs 1.15e-02, Document 1 B).\nQ8 : Ces résultats corroborent-ils ceux obtenus en considérant la variable comme continue ? Quelles différences observe-t-on entre les poissons pharyngognathes et non-pharyngognathes ?"
  },
  {
    "objectID": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1.html#diversification-des-régimes-alimentaires-et-radiation-évolutive-chez-les-cichlidés-des-grands-lacs-africains",
    "href": "Teaching/TD_Ecologie_Evolution/Ecologie_Evolution_TD1.html#diversification-des-régimes-alimentaires-et-radiation-évolutive-chez-les-cichlidés-des-grands-lacs-africains",
    "title": "TD 2 de Phylogénie",
    "section": "Diversification des régimes alimentaires et radiation évolutive chez les Cichlidés des grands lacs Africains",
    "text": "Diversification des régimes alimentaires et radiation évolutive chez les Cichlidés des grands lacs Africains\n\n\n\n\n\n\nDocument 2: Phylogénie RAxML des Tropheini calibrée temporellement et faisant apparaître les reconstructions des traits ancestraux pour la spécialisation trophique. (Singh et al 2022 DOI : 10.1002/ece3.9077)\nL’arbre a été reconstitué par maximum de vraisemblance. Les temps de divergences ont été inférés avec RelTime à partir d’un schéma de calibration vicariance-dépendant incluant des fossiles datés et la fragmentation du Gondwana. Les abscisses représentent le temps en millions d’années avant le présent. Les intervalles de confiance des nœuds clefs sont marqués par des boîtes bleues.\n\n\n\nQ9 : Quels sont les deux types d’informations utilisés pour calibrer temporellement cet arbre ? En quoi sont-elles complémentaires ? Sont-elles suffisantes pour calibrer l’entièreté de l’arbre ?\nQ10 : Interpréter le Document 2"
  }
]