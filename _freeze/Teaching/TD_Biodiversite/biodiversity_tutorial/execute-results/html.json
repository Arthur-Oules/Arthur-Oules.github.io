{
  "hash": "c6c4d035eca42f515e53efa36359a4ab",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"TD Biodiversité\"\nauthor: Arthur Oulès, adapté de [Güell *et al* (2017)](https://fuzzyatelin.github.io/bioanth-stats/module-24/module-24.html#introduction)\neditor: source\nformat:\n  html:\n    toc: true\n    toc-title: Sommaire\n    toc-location: left\n    code-tools:\n      source: https://github.com/Arthur-Oules/Arthur-Oules.github.io/tree/main/Teaching/TD_Biodiversite\n    code-fold: true\n    code-summary: Afficher le code\n    code-copy: true\n    link-external-newwindow: true\n    link-external-icon: true\n    lang: fr\n---\n\n\n\n# Chargement des packages et données\n\n## Chargement des packages\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# For data manipulation\nlibrary(here)\nlibrary(tidyverse)\nlibrary(reshape2)\nlibrary(rentrez)\n\n# For Phylogenetics\nlibrary(ape)\nlibrary(msa)\nlibrary(phangorn)\n\n# For visualization\nlibrary(ggtree)\nlibrary(viridis)\n```\n:::\n\n\n\n## Chargement des fonctions externes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(here(\"functions\", \"tidy_functions.R\"))\n```\n:::\n\n\n\n# Préliminaires\n\nDans le cadre de ce TP/TD, nous allons apprendre à générer des arbres phylogénétiques à partir de séquences ADN récupérées sur GenBank par diverses méthodes de construction d'arbre et les comparer entre elles.\n\nQuel est le protocole général pour construire un arbre phylogénétique à partir de séquences ADN ?\n\n# Acquisition des séquences\n\nNous allons commencer par récupérer les séquences d’intérêts sur Genbank directement depuis `R`.\\\nQu'est-ce que GenBank ? (5 min)\n\n## Chargement des données\n\nCharger le fichier `data/usflu.annot.csv` avec la fonction `read_csv()` et le visualiser. (5 min)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nannotations <- read_csv(\n  file           = here(\"data\", \"usflu.annot.csv\"),\n  show_col_types = FALSE\n) |> select(c(-1))\nview(annotations)\n```\n:::\n\n\n\nAller sur [GenBank](https://www.ncbi.nlm.nih.gov/nucleotide/) et entrer un numéro d'accès dans la barre de recherche. À quoi correspond-t-elle ?\\\nPourquoi l'indication \"Segment 4\" ?\\\nÀ quoi correspond la protéine codée par ce gène ? Quel est le rapport avec le nom du variant ?\\\nPouvez-vous faire des prédictions sur l'évolution de ces séquences ? (10 min)\n\n## Récupération des séquences par lot\n\nNous allons télécharger les séquences correspondantes depuis Genbank avec le package `rentrez` (ne pas faire tourner le bloc sauf avec une bonne connexion internet).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nannotations |>\n  mutate(\"sequences\" = Vectorize(Get_sequence)(accession)) |> \n  select(c(accession, sequences)) |> \n  write_to_fasta(path = here(\"output\", \"usflu_sequences.fasta\"))\n```\n:::\n\n\n\n# Alignement des séquences\nRappeler le principe de l'alignement de séquences. (5min)\\\n\nLe package `msa` (Multiple Sequence Alignment) permet d'utiliser les algorithmes classiques d'alignement de multiples séquences directement depuis `R`.\\\nOuvrir la page d'aide de la fonction `msa()`.\\\nQuels sont les algorithmes disponibles ? Sous quelle forme doit-on fournir les séquences à la fonction ? (5 min)\\\nCommencer par ouvrir le fichier fasta généré dans un format accepté par la fonction `msa()`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusflu_sequences <- readDNAStringSet(file = here(\"output\", \"usflu_sequences.fasta\"))\nusflu_sequences\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDNAStringSet object of length 80:\n     width seq                                              names               \n [1]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA CY013200\n [2]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA CY013781\n [3]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA CY012128\n [4]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA CY013613\n [5]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA CY012160\n ...   ... ...\n[76]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA FJ549055\n[77]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA EU779498\n[78]  1701 ATGAAGACTATCATTGCTTTGAG...TAGATGCAACATTTGCATTTGA EU779500\n[79]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA CY035190\n[80]  1701 ATGAAGACTATCATTGCTTTGAG...TAGGTGCAACATTTGCATTTGA EU852005\n```\n\n\n:::\n:::\n\n\n\nOn va utiliser l'algorithme MUSCLE pour générer notre alignement.\\\nUtiliser la fonction `msa()` avec les bons paramètres pour générer un alignement. (5 min)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalignment <- usflu_sequences |> msa(method = \"Muscle\", type = \"dna\", order = \"input\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n\nOuvrir le fichier `output/alignment.pdf` et observer l'alignement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem2(\n  \"open\",\n  args = c(\"-a Preview.app\", here(\"output\", \"alignment.pdf\")),\n  wait = FALSE\n)\n```\n:::\n\n\n\nMaintenant que nous avons aligné nos séquences, nous pouvons passer à la suite !\\\nRappeler les différentes méthodes de construction d'arbres phylogénétiques que vous connaissez. (5 min)\n\n# Méthode de distances\n\nRappeler le principe des méthodes de distance et en citer deux exemples.\\\nQuelles sont les différences entre ces méthodes ? (5 min)\n\n## Génération de la matrice de distances\n\nNous allons générer une matrice des distances à partir de nos alignements à l'aide la fonction `dist.dna()`. Ouvrir l'aide de cette fonction.\\\nCombien de modèles de substitution sont disponibles ? Comparer à la fonction `dist.ml()`. Aller sur [ce lien](http://www.iqtree.org/doc/Substitution-Models) (et [celui-ci](https://en.wikipedia.org/wiki/Models_of_DNA_evolution) pour approfondir) et regarder les différents modèles.\\\nQuelles sont les différences entre ces modèles ? Nous allons utiliser le modèle `TN93`, pourquoi ce nom ? Quelles sont ses particularités ? (5 min)\\\nUtiliser la fonction `dist.dna()` pour générer une matrice de distance.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# alignment_BIN <- adegenet::fasta2DNAbin(here(\"output\", \"alignment.fa\"))\nalignment_BIN <- alignment |> msaConvert(type = \"ape::DNAbin\") \ndistance_matrix <- alignment_BIN |>\n  dist.dna(model = \"TN93\")\n```\n:::\n\n\n\nNous allons visualiser la matrice de distance avec ggplot. Décrire la structure de cette portion de code. (5 min)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistance_matrix |>\n  as.matrix() |> melt() |>\n  ggplot(mapping = aes(x = Var1, y = Var2, fill = value)) +\n  geom_raster() +\n  scale_fill_viridis() +\n  ggtitle(\"Heatmap de la matrice des distances\") +\n  theme(\n    axis.title = element_blank()\n  )\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nPourquoi les valeurs en diagonale de la matrice sont nulles ? Identifiez-vous des tendances ? (5 min)\n\n## Génération et visualisation de l'arbre par UPGMA\n\nGénérer et visualiser un arbre avec l'algorithme UPGMA à l'aide des fonction `upgma()` et `plot()`. Commenter cet arbre. (5 min)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nUPGMA_tree <- upgma(distance_matrix)\nplot(UPGMA_tree, main = \"Arbre UPGMA\", cex = .6)\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# ggtree(UPGMA_tree) + geom_tiplab() + ggtitle(\"Arbre UPGMA\")\n```\n:::\n\n\n\n## Génération de l'arbre par Neighbour-Joining\n\nOuvrir l'aide de la fonction `NJ()`. Générer l'arbre et le visualiser avec la fonction plot().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNJ_tree <- distance_matrix |> NJ()\nplot(NJ_tree)\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nNous allons en profiter pour explorer la structure des arbres phylogénétiques en tant qu'objet sur R.\\\nPour commencer, explorer la structure de l'objet `NJ_tree` à l'aide de la fonction `class()` et de l'opérateur `$`\\\nLire la documentation de la fonction `read.tree`.\\\nEnregistrer l'arbre dans un fichier `.txt` à l'aide de la fonction `ape::write.tree()`. Comment est structuré ce fichier texte ?\\\nUtiliser les fonctions `plot()` et `nodelabel()` pour afficher l'arbre et les numéros des nœuds. (10 min)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(NJ_tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"phylo\"\n```\n\n\n:::\n\n```{.r .cell-code}\nNJ_tree\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nPhylogenetic tree with 80 tips and 78 internal nodes.\n\nTip labels:\n  CY013200, CY013781, CY012128, CY013613, CY012160, CY012272, ...\n\nUnrooted; includes branch lengths.\n```\n\n\n:::\n\n```{.r .cell-code}\nNJ_tree |> ape::write.tree(here(\"output\", \"NJ_tree.txt\"))\nplot(NJ_tree, cex = .6)\nnodelabels(frame = \"none\", cex = .6)\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\nNous allons voir comment visualiser ce même arbre en utilisant le package ggtree.\\\nCommenter le bloc de code suivant. Cette représentation vous semble-t-elle pertinente pour cette méthode ? (5 min)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(NJ_tree) + geom_tiplab() + geom_nodelab() + ggtitle(\"NJ non raciné\")\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nAjoutons des annotations à cet arbre :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(NJ_tree, layout = \"circular\") %<+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  ggtitle(\"NJ non raciné\") +\n  theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nA quoi correspondent les couleurs des feuilles de l'arbre ?\\\nNous allons raciner l'arbre de manière arbitraire. À partir de la figure précédente, quelle séquence vous semble pertinente pour raciner l'arbre ?\\\nRaciner l'arbre à l'aide de la fonction `root()`. (5 min)\\\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNJ_tree_rooted <- NJ_tree |> root(outgroup = \"CY012128\") |> ladderize()\nggtree(NJ_tree_rooted) %<+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  ggtitle(\"NJ raciné\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n! The tree contained negative edge lengths. If you want to ignore the edges,\nyou can set `options(ignore.negative.edge=TRUE)`, then re-run ggtree.\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nCommenter cet arbre. (5 min)\n\n## Quelle méthode choisir ?\n\nOn va se servir de la matrice de distance d'origine pour tester l'adéquation de la méthode choisie pour reconstruire l'arbre aux données de départ.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_NJ <- data.frame(\n    x = as.vector(distance_matrix),\n    y = NJ_tree_rooted |> cophenetic() |> as.dist() |> as.vector()\n)\n\ncorcoeff <- cor(data_NJ$x, data_NJ$y)^2\n\nggplot(data = data_NJ, mapping = aes(x = x, y = y)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", color = \"red\", size = .8) +\n  annotate(\"text\", x = .025, y = .055, color = \"red\",\n    label = paste0(\"Coefficient de correlation = \", as.character(corcoeff))) +\n  ggtitle(\"Est-ce que le NJ est approprié ?\") +\n  xlab(\"Distances par paires d'origine\") +\n  ylab(\"Distances par paires de l'arbre\") +\n  theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nLire l'aide de la fonction `cophenetic()`. Quelle valeur calcule-t-elle ? Quel type d'objet renvoie-t-elle ?\\\nQue représente ce graphique ? Comment l'interpréter ?\\\nComment est calculé le coefficient de corrélation ? (10 min)\\\n\\\nRecommençons avec l'arbre généré par UPGMA :\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_UPGMA <- data.frame(\n    x = as.vector(distance_matrix),\n    y = UPGMA_tree |> cophenetic() |> as.dist() |> as.vector()\n)\nggplot(\n  data = data_UPGMA,\n  mapping = aes(x = x, y = y)\n) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"red\") +\n  ggtitle(\"Est-ce que l'UPGMA est appropriée ?\") +\n  xlab(\"Distances par paires d'origine\") +\n  ylab(\"Distances par paires de l'arbre\") +\n  theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncor(data_UPGMA$x, data_UPGMA$y)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.7393009\n```\n\n\n:::\n:::\n\n\nQu'en concluez-vous sur cette méthode par rapport au Neighbour-Joining ? (5 min)\n\n## Bootstrap\nRappeler le principe du Bootstrap.\\\nÀ quoi sert-il dans ce contexte ? (5 min)\n\n### Calcul des valeurs de Bootstrap\n\nNous allons générer les indices de bootstrap pour chaque nœud de l'arbre.\\\nCommenter le bloc de code suivant :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrap_rooted_NJ <- boot.phylo(\n  NJ_tree_rooted,\n  alignment_BIN,\n  \\(x) {x |>\n      dist.dna(model = \"TN93\") |>\n      nj() |> \n      root(outgroup = \"CY012128\")\n  }\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nRunning bootstraps:       100 / 100\nCalculating bootstrap values... done.\n```\n\n\n:::\n\n```{.r .cell-code}\nNJ_tree_rooted$node.label <- bootstrap_rooted_NJ\n```\n:::\n\n\n\n### Impression de l'arbre bootstrappé\nNous allons afficher l'arbre précédent avec les valeurs de bootstrap que nous venons de calculer :\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(ignore.negative.edge=TRUE)\nggtree(NJ_tree_rooted) %<+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  geom_label2(\n    aes(\n      subset = !isTip,\n      label = label,\n    )\n  ) +\n  ggtitle(\"NJ raciné avec Bootstrap\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nCommenter cet arbre. Comment améliorer cet arbre en considérant les valeurs de bootstrap ? (5 min)\n\n### On retire les noeuds faibles\n\nCommenter le bloc de code suivant :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNJ_tree_rooted_collapsed <- NJ_tree_rooted\ntoCollapse <- match(\n  which(bootstrap_rooted_NJ < 70) + length(NJ_tree_rooted$tip.label),\n NJ_tree_rooted$edge[, 2]\n)\nNJ_tree_rooted_collapsed$edge.length[toCollapse] <- 0\nNJ_tree_rooted_collapsed <- di2multi(NJ_tree_rooted_collapsed, tol = 0.00001)\n```\n:::\n\n\n\nAffichons notre nouvel arbre :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(NJ_tree_rooted_collapsed) %<+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  geom_label2(\n    aes(\n      subset = !isTip,\n      label = label,\n    )\n  ) +\n  ggtitle(\"NJ raciné avec Bootstrap et sans les noeuds faibles\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nLe comparer au précédent, comment a-t-il été modifié ? (5 min)\n\n# Maximum de parcimonie\nRappeler le principe du maximum de parcimonie.\\\nLire l'aide de la fonction `optim.parsimony()`, à quoi correspondent les arguments `tree` et `data` ? Comment le relier au principe de la méthode ? Comment l'arbre optimal est-il obtenu ? (5 min)\n\n## Conversion de l'alignement dans le format phyDat\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# alignment_phyDat <- read.phyDat(\n#   file = here(\"output\", \"alignment.fa\"),\n#   format = \"fasta\"\n# )\nalignment_phyDat <- alignment |> msaConvert(type = \"phangorn::phyDat\")\nclass(alignment_phyDat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"phyDat\"\n```\n\n\n:::\n:::\n\n\n\n## Génération de l'arbre initial\nGénérons un arbre par Neighbour-Joining qui permettra d'initialiser l'algorithme de maximum de parcimonie.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMP_tree_init <- alignment_BIN |> dist.dna(model = \"TN93\") |> NJ()\n```\n:::\n\n\n\n## Génération de l'arbre le plus parcimonieux\nUtiliser la fonction `parcimony()` pour calculer le score de parcimonie de l'arbre initial.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparsimony(MP_tree_init, alignment_phyDat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 422\n```\n\n\n:::\n:::\n\n\nUtiliser la fonction `optim.parsimony()` pour générer l'arbre le plus parcimonieux.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMP_tree <- optim.parsimony(MP_tree_init, alignment_phyDat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nFinal p-score 420 after  2 nni operations \n```\n\n\n:::\n\n```{.r .cell-code}\nrm(MP_tree_init)\nMP_tree\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nPhylogenetic tree with 80 tips and 76 internal nodes.\n\nTip labels:\n  CY013200, CY013781, CY012128, CY013613, CY012160, CY012272, ...\n\nUnrooted; no branch lengths.\n```\n\n\n:::\n:::\n\n\nComparer les scores de parcimonie des deux arbres.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(MP_tree, layout = \"circular\") %<+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  ggtitle(\"Arbre maximum de parcimonie\") +\n  theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nCommenter l'arbre généré.\\\nComment expliquer la similarité avec les arbres précédents ? (10 min)\n\n# Maximum de vraisemblance\nRappeler le principe du maximum de vraisemblance. (5 min)\n\n## Initialisation\nSimilairement à la méthode du maximum de parcimonie, la méthode doit être initialisée avec un arbre :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nML_tree_init <- alignment_BIN |> dist.dna(model = \"TN93\") |> NJ()\n```\n:::\n\n\n\n### Calcul de la vraisemblance de l'arbre initial\nUtiliser la fonction `pml()` pour calculer la vraisemblance de l'arbre initial avec le paramètre `k = 4`. Ce paramètre décrit le nombre de classes de vitesses évolutives utilisées dans le modèle, la valeur `k = 4` est une valeur par défaut courante.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npml(ML_tree_init, alignment_phyDat, k = 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmodel: JC+G(4) \nloglikelihood: -5641.785 \nunconstrained loglikelihood: -4736.539 \nModel of rate heterogeneity: Discrete gamma model\nNumber of rate categories: 4 \nShape parameter: 1 \n       Rate Proportion\n1 0.1369538       0.25\n2 0.4767519       0.25\n3 1.0000000       0.25\n4 2.3862944       0.25\n\nRate matrix:\n  a c g t\na 0 1 1 1\nc 1 0 1 1\ng 1 1 0 1\nt 1 1 1 0\n\nBase frequencies:  \n   a    c    g    t \n0.25 0.25 0.25 0.25 \n```\n\n\n:::\n:::\n\n\n\nLa fonction a bien tourné mais elle est sensible à la nature des données, on va donc vérifier que le jeu de données est bien propre : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nalignment_phyDat |> as.character() |> table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    -     a     c     g     k     m     r     s     t     w \n  147 45595 27170 30613     1     2     1     1 32549     1 \n```\n\n\n:::\n:::\n\n\nCertains caractères de nos séquences ne correspondent pas aux bases azotées traditionnelles !\\\nLire [cette page](https://www.dnabaser.com/articles/IUPAC%20ambiguity%20codes.html) et identifier à quoi correspondent les lettres différentes de a, t, c et g.\\ À quoi correspondent les `'-'` ? (5 min).\\\n\nEnregistrons leur position dans un objet :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nna.posi <- which(\n  apply(\n    as.character(alignment_BIN),\n    2,\n    \\(x) any(!x %in% c(\"a\",\"t\",\"g\",\"c\"))\n  )\n)\n```\n:::\n\n\n\nVoyons la distribution de ces lettres :\\\nCommenter le bloc ce code ci-après. (5 min)\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(\n  as.character(alignment_BIN),\n  2,\n  \\(x) sum(!x %in% c(\"a\",\"t\",\"g\",\"c\"))\n) |>\n  plot(\n    type = \"l\",\n    col  = \"blue\",\n    xlab = \"Position in HA segment\",\n    ylab = \"Number of NAs\"\n  )\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\nRetirons les lettres différentes de a, t, c et g et vérifions que ça a bien fonctionné :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalignment_cropped <- alignment_BIN[, -na.posi]\nalignment_cropped |> as.character() |> table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    a     c     g     t \n43402 25104 28828 30346 \n```\n\n\n:::\n:::\n\n\nReconvertissons le jeu de donné trié au bon format :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nalignment_cropped_phyDat <- as.phyDat(alignment_cropped)\n```\n:::\n\n\n\nRegénérer l'arbre d'initialisation avec notre jeu de donnée nettoyé. (5 min)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nML_tree_init <- alignment_cropped |> dist.dna(model = \"TN93\") |> NJ()\nML_tree_init_L <- pml(ML_tree_init, alignment_cropped_phyDat, k = 4)\nML_tree_init_L\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmodel: JC+G(4) \nloglikelihood: -5184.119 \nunconstrained loglikelihood: -4043.367 \nModel of rate heterogeneity: Discrete gamma model\nNumber of rate categories: 4 \nShape parameter: 1 \n       Rate Proportion\n1 0.1369538       0.25\n2 0.4767519       0.25\n3 1.0000000       0.25\n4 2.3862944       0.25\n\nRate matrix:\n  a c g t\na 0 1 1 1\nc 1 0 1 1\ng 1 1 0 1\nt 1 1 1 0\n\nBase frequencies:  \n   a    c    g    t \n0.25 0.25 0.25 0.25 \n```\n\n\n:::\n:::\n\n\n\n## Génération de l'arbre le plus vraisemblable\nUtiliser la fonction `optim.pml()` pour générer l'arbre optimal avec les paramètres `model = \"GTR\", inv = .2,optNni = TRUE, optBf = TRUE, optQ = TRUE, optGamma = TRUE`, ce qui correspond à un modèle GTR + G(4) + I (Generalised time reversible + Gamma(4) + Invariants) très standard pour ce genre d'application. Il est également possible d'utiliser la fonction `modelTest()` pour choisir un modèle approprié automatiquement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nML_tree <- optim.pml(\n  ML_tree_init_L,\n  model    = \"GTR\",\n  inv      = .2,\n  optNni   = TRUE,\n  optBf    = TRUE,\n  optQ     = TRUE,\n  optGamma = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\noptimize edge weights:  -5139.288 --> -5121.539 \noptimize rate matrix:  -5121.539 --> -4933.61 \noptimize shape parameter:  -4933.61 --> -4919.39 \noptimize edge weights:  -4919.39 --> -4919.078 \noptimize topology:  -4919.078 --> -4915.934  NNI moves:  2 \noptimize rate matrix:  -4915.934 --> -4915.899 \noptimize shape parameter:  -4915.899 --> -4915.898 \noptimize edge weights:  -4915.898 --> -4915.898 \noptimize topology:  -4915.898 --> -4915.898  NNI moves:  0 \noptimize rate matrix:  -4915.898 --> -4915.898 \noptimize shape parameter:  -4915.898 --> -4915.898 \noptimize edge weights:  -4915.898 --> -4915.898 \n```\n\n\n:::\n\n```{.r .cell-code}\nML_tree\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmodel: GTR+G(4) \nloglikelihood: -4915.898 \nunconstrained loglikelihood: -4043.367 \nModel of rate heterogeneity: Discrete gamma model\nNumber of rate categories: 4 \nShape parameter: 0.2826837 \n         Rate Proportion\n1 0.003996013       0.25\n2 0.091111301       0.25\n3 0.565542826       0.25\n4 3.339349861       0.25\n\nRate matrix:\n         a          c         g         t\na 0.000000  2.3849152 8.3016092  0.863043\nc 2.384915  0.0000000 0.1472685 10.080389\ng 8.301609  0.1472685 0.0000000  1.000000\nt 0.863043 10.0803894 1.0000000  0.000000\n\nBase frequencies:  \n        a         c         g         t \n0.3398051 0.1966759 0.2259102 0.2376088 \n```\n\n\n:::\n:::\n\n\nComparons notre arbre optimal avec l'arbre initial généré par Neighbour-Joining :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(ML_tree_init_L, ML_tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLikelihood Ratio Test Table\n  Log lik.  Df Df change Diff log lik. Pr(>|Chi|)    \n1  -5184.1 158                                       \n2  -4915.9 166         8        536.44  < 2.2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nAIC(ML_tree_init_L, ML_tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                df      AIC\nML_tree_init_L 158 10684.24\nML_tree        166 10163.80\n```\n\n\n:::\n:::\n\n\nLire l'aide de la fonction `AIC`. À quoi sert l'indice d'Akaike ? (5 min)\nAffichons notre super arbre !\n\n\n::: {.cell}\n\n```{.r .cell-code}\nML_tree_rooted <- ML_tree$tree |> root(outgroup = \"CY012128\") |> ladderize()\nggtree(ML_tree_rooted) %<+% annotations +\n  geom_tiplab(aes(color = year)) +\n  scale_color_viridis(option = \"turbo\") +\n  geom_label2(\n    aes(\n      subset = !isTip,\n      label = label,\n    )\n  ) +\n  ggtitle(\"Maximum de vraisemblance\") +\n  theme(legend.position = \"right\") +\n  geom_rootedge(rootedge = .01) +\n  theme_tree2()\n```\n\n::: {.cell-output-display}\n![](biodiversity_tutorial_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "biodiversity_tutorial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}